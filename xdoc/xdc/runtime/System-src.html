<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module xdc.runtime.System</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* 
</span>     2    <span class="comment"> *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
</span>     3    <span class="comment"> *  This program and the accompanying materials are made available under the 
</span>     4    <span class="comment"> *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
</span>     5    <span class="comment"> *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
</span>     6    <span class="comment"> *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
</span>     7    <span class="comment"> *  Distribution License is available at 
</span>     8    <span class="comment"> *  http://www.eclipse.org/org/documents/edl-v10.php.
</span>     9    <span class="comment"> *
</span>    10    <span class="comment"> *  Contributors:
</span>    11    <span class="comment"> *      Texas Instruments - initial implementation
</span>    12    <span class="comment"> * */</span>
    13    <span class="comment">/*
</span>    14    <span class="comment"> *  ======== System.xdc ========
</span>    15    <span class="comment"> */</span>
    16    
    17    <span class=key>package</span> xdc.runtime;
    18    
    19    <span class="xdoc">/*!
</span>    20    <span class="xdoc"> *  ======== System ========
</span>    21    <span class="xdoc"> *  Basic system services
</span>    22    <span class="xdoc"> *
</span>    23    <span class="xdoc"> *  This module provides basic low-level "system" services; e.g.,
</span>    24    <span class="xdoc"> *  character output, `printf`-like output, and exit handling.
</span>    25    <span class="xdoc"> *
</span>    26    <span class="xdoc"> *  This module is gated and other modules use its gate via the
</span>    27    <span class="xdoc"> *  `{<b>@link</b> Gate#enterSystem}` and `{<b>@link</b> Gate#leaveSystem}`. The
</span>    28    <span class="xdoc"> *  `System` gate must be enterable by any thread in a multi-threaded
</span>    29    <span class="xdoc"> *  environments.  For example, in many real-time multi-threaded environments
</span>    30    <span class="xdoc"> *  some types of threads, such as Interrupt Service Routines (ISRs), are not
</span>    31    <span class="xdoc"> *  allowed to call operations that block the caller.  In such an environment,
</span>    32    <span class="xdoc"> *  either the `System` gate must disable all interrupts or ISRs must never
</span>    33    <span class="xdoc"> *  call a function in the `xdc.runtime` package.
</span>    34    <span class="xdoc"> */</span>
    35    
    36    @Template(<span class="string">"./System.xdt"</span>)
    37    @Gated
    38    @ModuleStartup
    39    <span class=key>module</span> System {
    40    
    41        <span class="xdoc">/*! 
</span>    42    <span class="xdoc">     *  ======== AtexitHandler ========
</span>    43    <span class="xdoc">     *  `System`'s atexit function prototype.
</span>    44    <span class="xdoc">     *
</span>    45    <span class="xdoc">     *  Fuctions of this type can be added to the list of functions that
</span>    46    <span class="xdoc">     *  are executed during application termination.
</span>    47    <span class="xdoc">     *
</span>    48    <span class="xdoc">     *  <b>@see</b> #atexit
</span>    49    <span class="xdoc">     */</span>
    50        <span class=key>typedef</span> Void (*AtexitHandler)(Int);
    51    
    52        <span class="xdoc">/*! 
</span>    53    <span class="xdoc">     *  ======== STATUS_UNKNOWN ========
</span>    54    <span class="xdoc">     *  Unknown exit status value
</span>    55    <span class="xdoc">     *
</span>    56    <span class="xdoc">     *  When the program exits by calling {<b>@link</b> #exit System_exit()} the
</span>    57    <span class="xdoc">     *  `System`'s `atexit` functions are passed the status value passed to
</span>    58    <span class="xdoc">     *  `System_exit()`.  However, if the program exits using 
</span>    59    <span class="xdoc">     *  the ANSI C Standard Library `exit()` function, the `System`'s `atexit`
</span>    60    <span class="xdoc">     *  functions are passed `System_STATUS_UNKNOWN`; ANSI C `atexit`
</span>    61    <span class="xdoc">     *  functions are not passed the exit status.
</span>    62    <span class="xdoc">     */</span>
    63        <span class=key>const</span> Int STATUS_UNKNOWN = 0xCAFE;
    64    
    65        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
    66        @XmlDtd
    67        <span class=key>metaonly</span> <span class=key>struct</span> Module_View {
    68            String  atexitHandlers[];
    69            Int     numAtexitHandlers;
    70        };
    71        
    72        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
    73        <span class=key>metaonly</span> <span class=key>struct</span> PathEntryView {
    74            String entry;
    75        }
    76    
    77        <span class="xdoc">/*!
</span>    78    <span class="xdoc">     *  ======== rovViewInfo ========
</span>    79    <span class="xdoc">     *  <b>@_nodoc</b>
</span>    80    <span class="xdoc">     */</span>
    81        @Facet
    82        <span class=key>metaonly</span> <span class=key>config</span> xdc.rov.ViewInfo.Instance rovViewInfo = 
    83            xdc.rov.ViewInfo.create({
    84                viewMap: [
    85                    [<span class="string">'XDCROOT'</span>,
    86                        {
    87                            type: xdc.rov.ViewInfo.MODULE_DATA,
    88                            viewInitFxn: <span class="string">'viewInitXdcRoot'</span>,
    89                            structName: <span class="string">'PathEntryView'</span>
    90                        }
    91                    ],
    92                    [<span class="string">'XDCPATH'</span>,
    93                        {
    94                            type: xdc.rov.ViewInfo.MODULE_DATA,
    95                            viewInitFxn: <span class="string">'viewInitXdcPath'</span>,
    96                            structName: <span class="string">'PathEntryView'</span>
    97                        }
    98                    ],
    99                ]
   100            });
   101       
   102        <span class="xdoc">/*!
</span>   103    <span class="xdoc">     *  ======== A_cannotFitIntoArg ========
</span>   104    <span class="xdoc">     *  Assert that the target's `Float` type fits in an `IArg`
</span>   105    <span class="xdoc">     *
</span>   106    <span class="xdoc">     *  This assertion is triggered when the `%f` format specifier is used,
</span>   107    <span class="xdoc">     *  the argument treated as an `IArg`, but for the current target
</span>   108    <span class="xdoc">     *  `sizeof(Float)` &gt; `sizeof(IArg)`.
</span>   109    <span class="xdoc">     */</span>
   110        <span class=key>config</span> Assert.Id A_cannotFitIntoArg = {
   111            msg: <span class="string">"A_cannotFitIntoArg: sizeof(Float) &gt; sizeof(Arg)"</span>
   112        };
   113    
   114        <span class="xdoc">/*!
</span>   115    <span class="xdoc">     *  ======== extendedFormats ========
</span>   116    <span class="xdoc">     *  Optional conversions supported by `{<b>@link</b> #printf System_printf}`
</span>   117    <span class="xdoc">     *
</span>   118    <span class="xdoc">     *  This string specifies the set of optional argument conversion
</span>   119    <span class="xdoc">     *  specifiers required by the application.  By reducing the number of
</span>   120    <span class="xdoc">     *  optional conversions understood by the `System {<b>@link</b> #printf}`
</span>   121    <span class="xdoc">     *  methods, it is possible to significantly reduce the code size
</span>   122    <span class="xdoc">     *  footprint of the `System` module.  This configuration parameter
</span>   123    <span class="xdoc">     *  enables one to balance `printf` functionality against code size
</span>   124    <span class="xdoc">     *  footprint.
</span>   125    <span class="xdoc">     *
</span>   126    <span class="xdoc">     *  The format of this string is simply a concatenated list of the desired
</span>   127    <span class="xdoc">     *  conversion specifiers (with the leading `%` character).  For example,
</span>   128    <span class="xdoc">     *  to support both `%f` and `%$L` set `extendedFormats` to `"%$L%f"`.
</span>   129    <span class="xdoc">     *
</span>   130    <span class="xdoc">     *  To disable all optional converstions, set `extendedFormats` to `null`
</span>   131    <span class="xdoc">     *  or the empty string ("").
</span>   132    <span class="xdoc">     *
</span>   133    <span class="xdoc">     *  For a complete list of supported extensions, see the
</span>   134    <span class="xdoc">     *  `{<b>@link</b> #printf System_printf}` "Extended_Format_Specifiers" section.
</span>   135    <span class="xdoc">     *
</span>   136    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   137    <span class="xdoc">     *  If an optional conversion is used by some part of the application and
</span>   138    <span class="xdoc">     *  it is not specified in `extendedFormats`, the conversion character(s)
</span>   139    <span class="xdoc">     *  and leading `%` are treated as ordinary characters to be output.  As
</span>   140    <span class="xdoc">     *  a result, all subsequent arguments will almost certainly be converted
</span>   141    <span class="xdoc">     *  using the wrong conversion specifier!
</span>   142    <span class="xdoc">     *
</span>   143    <span class="xdoc">     *  <b>@see</b> #printf
</span>   144    <span class="xdoc">     */</span>
   145        <span class=key>metaonly</span> <span class=key>config</span> String extendedFormats = <span class="string">"%$L%$S%$F"</span>;
   146    
   147        <span class="xdoc">/*!
</span>   148    <span class="xdoc">     *  ======== SupportProxy ========
</span>   149    <span class="xdoc">     *  The implementation module of the low-level system functions.
</span>   150    <span class="xdoc">     *
</span>   151    <span class="xdoc">     *  This configuration parameter allows one to "bind" a different
</span>   152    <span class="xdoc">     *  implementation of the low-level services required to implement
</span>   153    <span class="xdoc">     *  `System`.
</span>   154    <span class="xdoc">     *  <b>@p(code)</b>
</span>   155    <span class="xdoc">     *      var System = xdc.useModule("xdc.runtime.System");
</span>   156    <span class="xdoc">     *      var SysStd = xdc.useModule("xdc.runtime.SysStd");
</span>   157    <span class="xdoc">     *      System.SupportProxy = SysStd;
</span>   158    <span class="xdoc">     *  <b>@p</b>
</span>   159    <span class="xdoc">     *
</span>   160    <span class="xdoc">     *  If this parameter is not set, it defaults to `{<b>@link</b> SysMin}`.
</span>   161    <span class="xdoc">     */</span>
   162        <span class=key>proxy</span> SupportProxy <span class=key>inherits</span> ISystemSupport;
   163    
   164        <span class="xdoc">/*!
</span>   165    <span class="xdoc">     *  ======== maxAtexitHandlers ========
</span>   166    <span class="xdoc">     *  Maximum number of dynamic atexit handlers allowed in the system.
</span>   167    <span class="xdoc">     *
</span>   168    <span class="xdoc">     *  Maximum number of `System` `atexit` handlers set during runtime via
</span>   169    <span class="xdoc">     *  the `{<b>@link</b> System#atexit}` function.
</span>   170    <span class="xdoc">     *
</span>   171    <span class="xdoc">     */</span>
   172        <span class=key>config</span> Int maxAtexitHandlers = 8;
   173    
   174        <span class="xdoc">/*!
</span>   175    <span class="xdoc">     *  ======== abort ========
</span>   176    <span class="xdoc">     *  Print a message and abort currently running executable.
</span>   177    <span class="xdoc">     *
</span>   178    <span class="xdoc">     *  This is called when an executable abnormally terminates.  
</span>   179    <span class="xdoc">     *  The `System` gate is entered, the 
</span>   180    <span class="xdoc">     *  `{<b>@link</b> #SupportProxy}`'s `abort` function is called
</span>   181    <span class="xdoc">     *  and `abort` is called.
</span>   182    <span class="xdoc">     *  No exit functions bound via `System_atexit()` or the ANSI C Standard
</span>   183    <span class="xdoc">     *  Library `atexit()` functions are executed. 
</span>   184    <span class="xdoc">     *
</span>   185    <span class="xdoc">     *  <b>@param(str)</b> abort message (not a format string)
</span>   186    <span class="xdoc">     */</span>
   187        Void abort(String str);
   188    
   189        <span class="xdoc">/*!
</span>   190    <span class="xdoc">     *  ======== atexit ========
</span>   191    <span class="xdoc">     *  Add an exit handler
</span>   192    <span class="xdoc">     *
</span>   193    <span class="xdoc">     *  `System_atexit` pushes `handler` onto an internal stack of functions 
</span>   194    <span class="xdoc">     *  to be executed when system is exiting (e.g. `System_exit` or `exit` is
</span>   195    <span class="xdoc">     *  called). Up to `{<b>@link</b> #maxAtexitHandlers}` functions can be specified
</span>   196    <span class="xdoc">     *  in this manner.  During the exit processing, the functions are popped
</span>   197    <span class="xdoc">     *  off the internal stack and called until the stack is empty.
</span>   198    <span class="xdoc">     *
</span>   199    <span class="xdoc">     *  The `System` gate is entered before the `System_atexit` functions 
</span>   200    <span class="xdoc">     *  are called.
</span>   201    <span class="xdoc">     *
</span>   202    <span class="xdoc">     *  The `SupportProxy`'s `{<b>@link</b> ISystemSupport#exit}` function is called
</span>   203    <span class="xdoc">     *  after all the atexit functions are called.
</span>   204    <span class="xdoc">     *
</span>   205    <span class="xdoc">     *  <b>@param(handler)</b> the `AtexitHandler` to invoke during system
</span>   206    <span class="xdoc">     *                  exit processing.
</span>   207    <span class="xdoc">     *
</span>   208    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   209    <span class="xdoc">     *  If `FALSE` is returned, the exit handler was not added and it will
</span>   210    <span class="xdoc">     *  not be called during an exit.
</span>   211    <span class="xdoc">     */</span>
   212        Bool atexit(AtexitHandler handler);
   213    
   214        <span class="xdoc">/*!
</span>   215    <span class="xdoc">     *  ======== atexitMeta ========     
</span>   216    <span class="xdoc">     *  Add an exit handler during configuration
</span>   217    <span class="xdoc">     *
</span>   218    <span class="xdoc">     *  This is the static counterpart to `System_atexit()`. This method can
</span>   219    <span class="xdoc">     *  be used to add `atexit` handlers at configuration time.  These
</span>   220    <span class="xdoc">     *  handlers do not count against the `maxAtexitHandlers`.
</span>   221    <span class="xdoc">     *
</span>   222    <span class="xdoc">     *  <b>@param(handler)</b> the `AtexitHandler` to invoke during system
</span>   223    <span class="xdoc">     *                  exit processing.
</span>   224    <span class="xdoc">     */</span>
   225        <span class=key>metaonly</span> Void atexitMeta(AtexitHandler handler);
   226    
   227        <span class="xdoc">/*!
</span>   228    <span class="xdoc">     *  ======== exit ========
</span>   229    <span class="xdoc">     *  Exit currently running executable.
</span>   230    <span class="xdoc">     *
</span>   231    <span class="xdoc">     *  This function is called when an executable needs to terminate
</span>   232    <span class="xdoc">     *  normally.  This function sets the exit code and simply calls `exit`.
</span>   233    <span class="xdoc">     *  All functions bound via `System_atexit` or the ANSI C Standar Library
</span>   234    <span class="xdoc">     *  `atexit` function are then executed. The `{<b>@link</b> #SupportProxy}`'s
</span>   235    <span class="xdoc">     *  `exit` function is called during this time.
</span>   236    <span class="xdoc">     *
</span>   237    <span class="xdoc">     *  <b>@param(stat)</b>    exit status to return to calling environment.
</span>   238    <span class="xdoc">     */</span>
   239        Void exit(Int stat);
   240    
   241        <span class="xdoc">/*!
</span>   242    <span class="xdoc">     *  ======== putch ========
</span>   243    <span class="xdoc">     *  Output a single character
</span>   244    <span class="xdoc">     *
</span>   245    <span class="xdoc">     *  The `{<b>@link</b> #SupportProxy}`'s `putch` function is called
</span>   246    <span class="xdoc">     *  by this function.
</span>   247    <span class="xdoc">     *
</span>   248    <span class="xdoc">     *  <b>@param(ch)</b> character to be output.
</span>   249    <span class="xdoc">     */</span>
   250        Void putch(Char ch);
   251    
   252        <span class="xdoc">/*!
</span>   253    <span class="xdoc">     *  ======== flush ========
</span>   254    <span class="xdoc">     *  Flush standard System I/O     
</span>   255    <span class="xdoc">     *
</span>   256    <span class="xdoc">     *  This function causes any buffered output characters are "written"
</span>   257    <span class="xdoc">     *  to the output device.
</span>   258    <span class="xdoc">     *
</span>   259    <span class="xdoc">     *  The `{<b>@link</b> #SupportProxy}`'s `flush` function is called
</span>   260    <span class="xdoc">     *  by this function.
</span>   261    <span class="xdoc">     */</span>
   262        Void flush();
   263    
   264        <span class="xdoc">/*!
</span>   265    <span class="xdoc">     *  ======== printf ========
</span>   266    <span class="xdoc">     *  A smaller faster printf
</span>   267    <span class="xdoc">     *
</span>   268    <span class="xdoc">     *  This function behaves much like the ANSI C Standard `printf`
</span>   269    <span class="xdoc">     *  but does not support the full range of format strings specified by
</span>   270    <span class="xdoc">     *  the C Standard.  In addition, several non-standard format specifiers
</span>   271    <span class="xdoc">     *  are recognized.
</span>   272    <span class="xdoc">     *
</span>   273    <span class="xdoc">     *  <b>@a(Format Strings)</b>
</span>   274    <span class="xdoc">     *  The format string is a character string composed of zero or
</span>   275    <span class="xdoc">     *  more directives: ordinary characters (not %), which are copied
</span>   276    <span class="xdoc">     *  unchanged to the output stream; and conversion specifications, each of
</span>   277    <span class="xdoc">     *  which results in fetching zero or more subsequent arguments.  Each
</span>   278    <span class="xdoc">     *  conversion specification is introduced by the character %, and ends
</span>   279    <span class="xdoc">     *  with a conversion specifier.  In between there may be (in this order)
</span>   280    <span class="xdoc">     *  zero or more flags, an optional minimum field width, an optional
</span>   281    <span class="xdoc">     *  precision and an optional length modifier.
</span>   282    <span class="xdoc">     *
</span>   283    <span class="xdoc">     *  <b>@a(Flags)</b>
</span>   284    <span class="xdoc">     *  The following flags are supported:
</span>   285    <span class="xdoc">     *  <b>@p(dlist)</b>
</span>   286    <span class="xdoc">     *      - `-`
</span>   287    <span class="xdoc">     *          The converted value is to be left adjusted on the field
</span>   288    <span class="xdoc">     *          boundary (the default is right justification.)
</span>   289    <span class="xdoc">     *      - `0`
</span>   290    <span class="xdoc">     *          The value should be zero padded. For d, i, o, u, and x
</span>   291    <span class="xdoc">     *          conversions, the converted value is padded on the left
</span>   292    <span class="xdoc">     *          with zeros rather than blanks.
</span>   293    <span class="xdoc">     *  <b>@p</b>
</span>   294    <span class="xdoc">     *
</span>   295    <span class="xdoc">     *  <b>@a(Field Width)</b>
</span>   296    <span class="xdoc">     *  The optional field width specifier is a decimal digit string (with
</span>   297    <span class="xdoc">     *  nonzero first digit) specifying a minimum field width. If the
</span>   298    <span class="xdoc">     *  converted value has fewer characters than the field width, it will
</span>   299    <span class="xdoc">     *  be padded with spaces on the left (or right, if the left-adjustment
</span>   300    <span class="xdoc">     *  flag has been given).  Instead of a decimal digit string one may
</span>   301    <span class="xdoc">     *  write `*` to specify that the field width is given in the next
</span>   302    <span class="xdoc">     *  argument.  A negative field width is taken as a '-' flag followed
</span>   303    <span class="xdoc">     *  by a positive field width.
</span>   304    <span class="xdoc">     *
</span>   305    <span class="xdoc">     *  <b>@a(Precision)</b>
</span>   306    <span class="xdoc">     *  The optional precision specifier is a period ('.') followed by an
</span>   307    <span class="xdoc">     *  optional decimal digit string.  Instead of a decimal digit string
</span>   308    <span class="xdoc">     *  one may write `*` to specify that the precision is given in the 
</span>   309    <span class="xdoc">     *  next argument which must be of type int.
</span>   310    <span class="xdoc">     *
</span>   311    <span class="xdoc">     *  If the precision is given as just '.', or the precision is
</span>   312    <span class="xdoc">     *  negative, the precision is taken to be zero.  This gives the
</span>   313    <span class="xdoc">     *  minimum number of digits to appear for d, i, o, u, and x
</span>   314    <span class="xdoc">     *  conversions, or the maximum number of characters to be printed from
</span>   315    <span class="xdoc">     *  a string for s conversions.
</span>   316    <span class="xdoc">     *
</span>   317    <span class="xdoc">     *  <b>@a(Length Modifiers)</b>
</span>   318    <span class="xdoc">     *  The optional length modifier is a single character from the following
</span>   319    <span class="xdoc">     *  list.
</span>   320    <span class="xdoc">     *  <b>@p(dlist)</b>
</span>   321    <span class="xdoc">     *      - `l`
</span>   322    <span class="xdoc">     *          A  following integer conversion corresponds to a long int
</span>   323    <span class="xdoc">     *          or unsigned long int argument
</span>   324    <span class="xdoc">     *
</span>   325    <span class="xdoc">     *  <b>@p</b>
</span>   326    <span class="xdoc">     *
</span>   327    <span class="xdoc">     *  <b>@a(Conversion Specifiers)</b>
</span>   328    <span class="xdoc">     *  The following conversion specifiers are supported.
</span>   329    <span class="xdoc">     *  <b>@p(dlist)</b>
</span>   330    <span class="xdoc">     *      - `d`, `i`
</span>   331    <span class="xdoc">     *          signed integer
</span>   332    <span class="xdoc">     *      - `u`
</span>   333    <span class="xdoc">     *          unsigned decimal
</span>   334    <span class="xdoc">     *      - `x`
</span>   335    <span class="xdoc">     *          unsigned hex
</span>   336    <span class="xdoc">     *      - `o`
</span>   337    <span class="xdoc">     *          unsigned octal
</span>   338    <span class="xdoc">     *      - `p`
</span>   339    <span class="xdoc">     *          pointer (@ + hex num)
</span>   340    <span class="xdoc">     *      - `c`
</span>   341    <span class="xdoc">     *          character
</span>   342    <span class="xdoc">     *      - `s`
</span>   343    <span class="xdoc">     *          string
</span>   344    <span class="xdoc">     *  <b>@p</b>
</span>   345    <span class="xdoc">     *  <b>@a(Extended Conversion Specifiers)</b>
</span>   346    <span class="xdoc">     *  The following conversion specifiers are optionally supported.  See
</span>   347    <span class="xdoc">     *  the `{<b>@link</b> #extendedFormats}` configuration parameter for more
</span>   348    <span class="xdoc">     *  information about how to enable these conversion specifiers.
</span>   349    <span class="xdoc">     *
</span>   350    <span class="xdoc">     *  <b>@p(dlist)</b>
</span>   351    <span class="xdoc">     *      - `f`
</span>   352    <span class="xdoc">     *          decimal floating point.
</span>   353    <span class="xdoc">     *      - `$`
</span>   354    <span class="xdoc">     *          non-ANSI conversion prefix.  This prefix indicates that the
</span>   355    <span class="xdoc">     *          next character identifies a non-ANSI standard conversion. See
</span>   356    <span class="xdoc">     *          the next section for details.
</span>   357    <span class="xdoc">     *  <b>@p</b>
</span>   358    <span class="xdoc">     *
</span>   359    <span class="xdoc">     *  <b>@a(Non ANSI Conversion Specifiers)</b>
</span>   360    <span class="xdoc">     *  Among the extended conversion specifiers are unique specifiers which
</span>   361    <span class="xdoc">     *  are not part of ANSI printf. These are specified using a $, for 
</span>   362    <span class="xdoc">     *  example %$L.
</span>   363    <span class="xdoc">     *
</span>   364    <span class="xdoc">     *  These unique specifiers do not support the minimum field width
</span>   365    <span class="xdoc">     *  attribute. Certain specifiers have additional restrictions; see below.
</span>   366    <span class="xdoc">     *  
</span>   367    <span class="xdoc">     *  <b>@p(dlist)</b>
</span>   368    <span class="xdoc">     *      - '$L'
</span>   369    <span class="xdoc">     *          The argument is treated as a pointer to a `{<b>@link</b> Types#Label}`
</span>   370    <span class="xdoc">     *          and is converted to an appropriate string.
</span>   371    <span class="xdoc">     *      - '$F'
</span>   372    <span class="xdoc">     *          Displays a file and line number; used for displaying the call 
</span>   373    <span class="xdoc">     *          site. This specifier consumes two arguments, the file and line 
</span>   374    <span class="xdoc">     *          number, in that order. See an example below.
</span>   375    <span class="xdoc">     *      - '$S'
</span>   376    <span class="xdoc">     *          The argument is treated as a format string, and is recursively
</span>   377    <span class="xdoc">     *          formatted using any following arguments. This specifier does 
</span>   378    <span class="xdoc">     *          not support the use of the "precision" field for specifying 
</span>   379    <span class="xdoc">     *          maximum string length.
</span>   380    <span class="xdoc">     *  <b>@p</b>
</span>   381    <span class="xdoc">     * 
</span>   382    <span class="xdoc">     *  The following are example uses of the %$F and %$S format specifiers.
</span>   383    <span class="xdoc">     *  
</span>   384    <span class="xdoc">     *  In this call using %$F, the compiler recognizes these symbols and
</span>   385    <span class="xdoc">     *  fills in the file and line number.
</span>   386    <span class="xdoc">     *  <b>@p(code)</b>
</span>   387    <span class="xdoc">     *  System_printf("%$F", __FILE__, __LINE__);
</span>   388    <span class="xdoc">     *  <b>@p</b>
</span>   389    <span class="xdoc">     *  This call outputs, for example,
</span>   390    <span class="xdoc">     *  <b>@p(code)</b>
</span>   391    <span class="xdoc">     *  "MyCode.c", line 35: 
</span>   392    <span class="xdoc">     *  <b>@p</b>
</span>   393    <span class="xdoc">     *  Here is an example using %$S, passing a recursive format string.
</span>   394    <span class="xdoc">     *  <b>@p(code)</b>
</span>   395    <span class="xdoc">     *  System_printf("Msg: %$S", "My msg, code: %d", 5);
</span>   396    <span class="xdoc">     *  <b>@p</b>
</span>   397    <span class="xdoc">     *  This outputs:
</span>   398    <span class="xdoc">     *  <b>@p(code)</b>
</span>   399    <span class="xdoc">     *  Msg: My msg, code: 5
</span>   400    <span class="xdoc">     *  <b>@p</b>
</span>   401    <span class="xdoc">     *
</span>   402    <span class="xdoc">     *  <b>@param(fmt)</b> a 'printf-style' format string
</span>   403    <span class="xdoc">     *
</span>   404    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   405    <span class="xdoc">     *  `printf` returns the number of characters printed.
</span>   406    <span class="xdoc">     */</span>
   407        Int printf(String fmt, ...);
   408    
   409        <span class="xdoc">/*!
</span>   410    <span class="xdoc">     *  ======== aprintf ========
</span>   411    <span class="xdoc">     *  `{<b>@link</b> #printf}` where all optional arguments are `IArg`s
</span>   412    <span class="xdoc">     *
</span>   413    <span class="xdoc">     *  This function will treat each argument as though it was widened to be 
</span>   414    <span class="xdoc">     *  of type `IArg` prior to being passed to the `{<b>@link</b> #printf}` function
</span>   415    <span class="xdoc">     *
</span>   416    <span class="xdoc">     *  <b>@see</b> #printf
</span>   417    <span class="xdoc">     */</span>
   418        Int aprintf(String fmt, ...);
   419    
   420        <span class="xdoc">/*!
</span>   421    <span class="xdoc">     *  ======== sprintf ========
</span>   422    <span class="xdoc">     *  Write formated output to a character buffer
</span>   423    <span class="xdoc">     *
</span>   424    <span class="xdoc">     *  This function is identical to `{<b>@link</b> #printf}` except that the
</span>   425    <span class="xdoc">     *  output is copied to the specified character buffer `buf` followed
</span>   426    <span class="xdoc">     *  by a terminating '\0' character.
</span>   427    <span class="xdoc">     *
</span>   428    <span class="xdoc">     *  <b>@param(buf)</b> a character output buffer
</span>   429    <span class="xdoc">     *  <b>@param(fmt)</b> a 'printf-style' format string
</span>   430    <span class="xdoc">     *
</span>   431    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   432    <span class="xdoc">     *  `sprintf` returns the number of characters output not including the
</span>   433    <span class="xdoc">     *  '\0' termination character.
</span>   434    <span class="xdoc">     */</span>
   435        Int sprintf(Char buf[], String fmt, ...);
   436    
   437        <span class="xdoc">/*!
</span>   438    <span class="xdoc">     *  ======== asprintf ========
</span>   439    <span class="xdoc">     *  `{<b>@link</b> #sprintf}` where all optional arguments are `IArg`s
</span>   440    <span class="xdoc">     *
</span>   441    <span class="xdoc">     *  This function will treat each argument as though it was widened to be 
</span>   442    <span class="xdoc">     *  of type `IArg` prior to being passed to the `{<b>@link</b> #sprintf}`
</span>   443    <span class="xdoc">     *  function.
</span>   444    <span class="xdoc">     *
</span>   445    <span class="xdoc">     *  <b>@see</b> #sprintf
</span>   446    <span class="xdoc">     */</span>
   447        Int asprintf(Char buf[], String fmt, ...);
   448    
   449        <span class="xdoc">/*!
</span>   450    <span class="xdoc">     *  ======== vprintf ========
</span>   451    <span class="xdoc">     *  A VaList printf
</span>   452    <span class="xdoc">     *
</span>   453    <span class="xdoc">     *  This function is identical to `{<b>@link</b> #printf}` except that its
</span>   454    <span class="xdoc">     *  arguments are passed via a VaList (a "varargs list").
</span>   455    <span class="xdoc">     *
</span>   456    <span class="xdoc">     *  <b>@param(fmt)</b> a standard 'printf-style' format string.
</span>   457    <span class="xdoc">     *  <b>@param(va)</b>  an args list that points to the arguments referenced
</span>   458    <span class="xdoc">     *              by the fmt string
</span>   459    <span class="xdoc">     *
</span>   460    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   461    <span class="xdoc">     *  `vprintf` returns the number of characters output.
</span>   462    <span class="xdoc">     */</span>
   463        Int vprintf(String fmt, VaList va);
   464    
   465        <span class="xdoc">/*!
</span>   466    <span class="xdoc">     *  ======== avprintf ========
</span>   467    <span class="xdoc">     *  `{<b>@link</b> #vprintf}` where all optional arguments are `IArg`s
</span>   468    <span class="xdoc">     *
</span>   469    <span class="xdoc">     *  This function will treat each argument as though it was widened to be 
</span>   470    <span class="xdoc">     *  of type `IArg` prior to being passed to the `{<b>@link</b> #vprintf}`
</span>   471    <span class="xdoc">     *  function.
</span>   472    <span class="xdoc">     *
</span>   473    <span class="xdoc">     *  <b>@see</b> #vprintf
</span>   474    <span class="xdoc">     */</span>
   475        Int avprintf(String fmt, VaList va);
   476    
   477        <span class="xdoc">/*!
</span>   478    <span class="xdoc">     *  ======== vsprintf ========
</span>   479    <span class="xdoc">     *  A `VaList` sprintf
</span>   480    <span class="xdoc">     *
</span>   481    <span class="xdoc">     *  This function is identical to `{<b>@link</b> #sprintf}` except that 
</span>   482    <span class="xdoc">     *  its arguments are passed via a `VaList` (a "varargs list").
</span>   483    <span class="xdoc">     *
</span>   484    <span class="xdoc">     *  <b>@param(buf)</b> a character output buffer
</span>   485    <span class="xdoc">     *  <b>@param(fmt)</b> a standard '`printf`-style' format string.
</span>   486    <span class="xdoc">     *  <b>@param(va)</b>  an arguments list that points to the arguments referenced
</span>   487    <span class="xdoc">     *              by the `fmt` string
</span>   488    <span class="xdoc">     *
</span>   489    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   490    <span class="xdoc">     *  `vsprintf` returns the number of characters output.
</span>   491    <span class="xdoc">     */</span>
   492        Int vsprintf(Char buf[], String fmt, VaList va);
   493    
   494        <span class="xdoc">/*!
</span>   495    <span class="xdoc">     *  ======== avsprintf ========
</span>   496    <span class="xdoc">     *  `{<b>@link</b> #vsprintf}` where all optional arguments are `IArg`s
</span>   497    <span class="xdoc">     *
</span>   498    <span class="xdoc">     *  This function is identical to `{<b>@link</b> #sprintf}` except that 
</span>   499    <span class="xdoc">     *  its arguments are passed via a `VaList` (a "varargs list").
</span>   500    <span class="xdoc">     *
</span>   501    <span class="xdoc">     *  This function will treat each argument as though it was widened to be 
</span>   502    <span class="xdoc">     *  of type `IArg` prior to being passed to the `vsprintf` function
</span>   503    <span class="xdoc">     *
</span>   504    <span class="xdoc">     *  <b>@see</b> #vsprintf
</span>   505    <span class="xdoc">     */</span>
   506        Int avsprintf(Char buf[], String fmt, VaList va);
   507        
   508    <span class=key>internal</span>:
   509    
   510        <span class="xdoc">/*! struct used to keep track of state during doPrint */</span>
   511        <span class=key>struct</span> ParseData {
   512            Int     width;      <span class="comment">/* width in format specifier */</span>
   513            Bool    lFlag;      <span class="comment">/* length modifier flag */</span>
   514            Bool    lJust;      <span class="comment">/* left justify flag */</span>
   515            Int     precis;     <span class="comment">/* precision in format specifier */</span>
   516            Int     len;        <span class="comment">/* length of formatted number */</span>
   517            Int     zpad;       <span class="comment">/* leading zero pad flag */</span>
   518            Char    *end;       <span class="comment">/* pointer to end of local buf to hold num */</span>
   519            Bool    aFlag;      <span class="comment">/* deal with vars on stack as IArgs */</span>
   520            Char    *ptr;       <span class="comment">/* ptr to local buf after filling in num */</span>
   521        };
   522    
   523        <span class="xdoc">/*! typedef for generated functions to process extended formats */</span>
   524        <span class=key>typedef</span> Int (*ExtendFxn)(Char **, Char **, VaList *, ParseData *);
   525    
   526        <span class="xdoc">/*! config parameter used to call generated function  */</span>
   527        <span class=key>readonly</span> <span class=key>config</span> ExtendFxn extendFxn = <span class="string">'&amp;xdc_runtime_System_printfExtend__I'</span>;
   528        
   529        <span class="comment">/*
</span>   530    <span class="comment">     * ======== printfExtend ======== 
</span>   531    <span class="comment">     *  System_printfExtend is generated based on extendedFormats string
</span>   532    <span class="comment">     *
</span>   533    <span class="comment">     *  This generated function is accessed through an internal config so
</span>   534    <span class="comment">     *  that it is an indirect call in the ROM case, but optimized to a direct
</span>   535    <span class="comment">     *  call in the RAM case.
</span>   536    <span class="comment">     *
</span>   537    <span class="comment">     * @_nodoc
</span>   538    <span class="comment">     */</span>
   539        Int printfExtend (Char **bufp, Char **fmt, VaList *va, ParseData *parse);
   540    
   541        <span class="xdoc">/*!
</span>   542    <span class="xdoc">     *  ======== exitFxns ========
</span>   543    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   544    <span class="xdoc">     *  List of functions statically plugged to be called at exit
</span>   545    <span class="xdoc">     *
</span>   546    <span class="xdoc">     */</span>
   547        <span class=key>metaonly</span> <span class=key>config</span> AtexitHandler exitFxns[];
   548        
   549        <span class="xdoc">/*!
</span>   550    <span class="xdoc">     *  ======== mprintf ========     
</span>   551    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   552    <span class="xdoc">     */</span>
   553        <span class=key>function</span> mprintf(fmt, args);
   554        
   555        <span class="xdoc">/*!
</span>   556    <span class="xdoc">     *  ======== doPrint ========
</span>   557    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   558    <span class="xdoc">     */</span>
   559        Int doPrint(Char buf[], String fmt, VaList *pva, Bool aFlag);
   560        
   561        <span class="xdoc">/*!
</span>   562    <span class="xdoc">     *  ======== formatNum ========
</span>   563    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   564    <span class="xdoc">     *
</span>   565    <span class="xdoc">     */</span>
   566        Char *formatNum(Char *ptr, UInt32 n, Int zpad, Int base);
   567    
   568        <span class="xdoc">/*!
</span>   569    <span class="xdoc">     *  ======== lastFxn ========
</span>   570    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   571    <span class="xdoc">     *
</span>   572    <span class="xdoc">     *  Calls atexit() after all other modules have been initialized
</span>   573    <span class="xdoc">     *  This used to be done in System_Module_startup() but this caused
</span>   574    <span class="xdoc">     *  problems since atexit() uses a heap which isn't necessarily
</span>   575    <span class="xdoc">     *  initialized.
</span>   576    <span class="xdoc">     */</span>
   577        Void lastFxn();
   578        
   579        <span class="xdoc">/*!
</span>   580    <span class="xdoc">     *  ======== putchar ========
</span>   581    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   582    <span class="xdoc">     *
</span>   583    <span class="xdoc">     *  Write character ch to the buffer and, if the buffer pointer is
</span>   584    <span class="xdoc">     *  non-`NULL`, update the buffer pointer.
</span>   585    <span class="xdoc">     */</span>
   586        Void putchar(Char **bufp, Char ch);
   587        
   588        <span class="xdoc">/*!
</span>   589    <span class="xdoc">     *  ======== rtsExit ========
</span>   590    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   591    <span class="xdoc">     */</span>
   592        Void rtsExit();
   593    
   594        <span class="xdoc">/*!
</span>   595    <span class="xdoc">     *  ======== Module_State ========
</span>   596    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   597    <span class="xdoc">     */</span>
   598        <span class=key>struct</span> Module_State {
   599            AtexitHandler  atexitHandlers[];   <span class="comment">/* array of atexit handlers       */</span>
   600            Int            numAtexitHandlers;  <span class="comment">/* Current num of atexit handlers */</span>
   601            Int            exitStatus;         <span class="comment">/* status for exit handlers       */</span>
   602        };
   603    }
   604    <span class="comment">/*
</span>   605    <span class="comment"> *  @(#) xdc.runtime; 2, 1, 0,371; 2-10-2012 10:18:55; /db/ztree/library/trees/xdc/xdc-y21x/src/packages/
</span>   606    <span class="comment"> */</span>
   607    
</pre>
</body></html>
