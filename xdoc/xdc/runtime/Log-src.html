<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module xdc.runtime.Log</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* 
</span>     2    <span class="comment"> *  Copyright (c) 2008 Texas Instruments. All rights reserved.
</span>     3    <span class="comment"> *  This program and the accompanying materials are made available under the
</span>     4    <span class="comment"> *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
</span>     5    <span class="comment"> *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
</span>     6    <span class="comment"> *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
</span>     7    <span class="comment"> *  Distribution License is available at
</span>     8    <span class="comment"> *  http://www.eclipse.org/org/documents/edl-v10.php.
</span>     9    <span class="comment"> *
</span>    10    <span class="comment"> *  Contributors:
</span>    11    <span class="comment"> *      Texas Instruments - initial implementation
</span>    12    <span class="comment"> * */</span>
    13    <span class="comment">/*
</span>    14    <span class="comment"> *  ======== Log.xdc ========
</span>    15    <span class="comment"> */</span>
    16    
    17    <span class="xdoc">/*!
</span>    18    <span class="xdoc"> *  ======== Log ========
</span>    19    <span class="xdoc"> *  Event logging manager
</span>    20    <span class="xdoc"> *
</span>    21    <span class="xdoc"> *  RTSC modules and the application code generate `{<b>@link</b> #Event Log_Event}`
</span>    22    <span class="xdoc"> *  events by calling the `Log` module's functions. The `Log` module then
</span>    23    <span class="xdoc"> *  passes those events to an `{<b>@link</b> ILogger}` instance assigned to the event
</span>    24    <span class="xdoc"> *  originating module, specified by that module's configuration parameter
</span>    25    <span class="xdoc"> *  `common$.logger`. `ILogger` instances handle events, usually converting
</span>    26    <span class="xdoc"> *  events to `{<b>@link</b> #EventRec Log_EventRec}` records prior to recording,
</span>    27    <span class="xdoc"> *  transmitting, or displaying them.
</span>    28    <span class="xdoc"> *
</span>    29    <span class="xdoc"> *  All events generated by a target module are stored and displayed by an
</span>    30    <span class="xdoc"> *  `ILogger`, examples of which are instances of
</span>    31    <span class="xdoc"> *  `{<b>@link</b> LoggerBuf xdc.runtime.LoggerBuf}` or
</span>    32    <span class="xdoc"> *  `{<b>@link</b> LoggerSys xdc.runtime.LoggerSys}`. At runtime, modules
</span>    33    <span class="xdoc"> *  generate events through this module, rather than invoking directly their
</span>    34    <span class="xdoc"> *  `ILogger`s. By doing so,  modules can be configured to use different
</span>    35    <span class="xdoc"> *  `ILogger` implementations without any changes to their source code.
</span>    36    <span class="xdoc"> *
</span>    37    <span class="xdoc"> *  A logger instance can accept `Log` events from any module, but a module
</span>    38    <span class="xdoc"> *  can put `Log` events to only one logger instance. There can be one or
</span>    39    <span class="xdoc"> *  more logger instances in a system. All `Log` calls that are not in a
</span>    40    <span class="xdoc"> *  module are controlled by the module `{<b>@link</b> Main xdc.runtime.Main}`.
</span>    41    <span class="xdoc"> *  For example, top-level application code or any existing sources that
</span>    42    <span class="xdoc"> *  simply call the `Log` or `Assert` methods implicitly use the logger
</span>    43    <span class="xdoc"> *  associated with the `Main` module.
</span>    44    <span class="xdoc"> *
</span>    45    <span class="xdoc"> *  The generation of a `Log` event is controlled by a module's diagnostics
</span>    46    <span class="xdoc"> *  mask, which is described in details in `{<b>@link</b> Diags}`. Each `Log` event
</span>    47    <span class="xdoc"> *  is associated with a mask. `Log` events are generated only when a
</span>    48    <span class="xdoc"> *  particular bit is set in both the `Log` event mask
</span>    49    <span class="xdoc"> *  and the module's diagnostics mask. For example, a `Log` event mask with
</span>    50    <span class="xdoc"> *  the `{<b>@link</b> Diags#USER1 USER1}` bit set is generated only when the `USER1`
</span>    51    <span class="xdoc"> *  bit is also set in the module's diagnostics mask.
</span>    52    <span class="xdoc"> *
</span>    53    <span class="xdoc"> *  There are two ways to generate `Log` events:
</span>    54    <span class="xdoc"> *
</span>    55    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    56    <span class="xdoc"> *  - `{<b>@link</b> #write8 Log_write()}`, which is tailored for module writers
</span>    57    <span class="xdoc"> *  and takes full advantage of the XDC configuration model. For example,
</span>    58    <span class="xdoc"> *  the message string associated with the `Log` event need not be a part of
</span>    59    <span class="xdoc"> *  the final application, significantly reducing the "footprint overhead"
</span>    60    <span class="xdoc"> *  of embedding diagnostics in deployed systems. The `Log_write[0-8]()`
</span>    61    <span class="xdoc"> *  functions allow up to 8 values to be passed to the logger. They expect
</span>    62    <span class="xdoc"> *  the logger to handle any formatting. A `Log` event type allows you to
</span>    63    <span class="xdoc"> *  specify the type of event.
</span>    64    <span class="xdoc"> *  - `{<b>@link</b> #print6 Log_print()}`, which is designed for arbitrary C code.
</span>    65    <span class="xdoc"> *  The `Log_print[0-6]()` functions allow up to 6 values to be passed along
</span>    66    <span class="xdoc"> *  with a printf-like format string to the logger. They handle printf-style
</span>    67    <span class="xdoc"> *  formatting.
</span>    68    <span class="xdoc"> *  <b>@p</b>
</span>    69    <span class="xdoc"> *
</span>    70    <span class="xdoc"> *  Both functions are controlled by the module's diagnostics mask. Their
</span>    71    <span class="xdoc"> *  storage or output is defined by the logger that is assigned to the
</span>    72    <span class="xdoc"> *  module that calls the `Log` methods or to the
</span>    73    <span class="xdoc"> *  `{<b>@link</b> Main xdc.runtime.Main}` module if the caller is not part of a
</span>    74    <span class="xdoc"> *  module.
</span>    75    <span class="xdoc"> *
</span>    76    <span class="xdoc"> *  The `Log` function call sites are implemented in such a way that an
</span>    77    <span class="xdoc"> *  optimizer can completely eliminate `Log` code from the program if the
</span>    78    <span class="xdoc"> *  `Log` functions have been permanently disabled at configuration time. If
</span>    79    <span class="xdoc"> *  the `Log` functions are permanently turned on at configuration time,
</span>    80    <span class="xdoc"> *  then the optimizer can eliminate all runtime conditional checking and
</span>    81    <span class="xdoc"> *  simply invoke the `Log` functions directly. Runtime checking is performed
</span>    82    <span class="xdoc"> *  only when the `Log` functions are configured to be runtime modifiable.
</span>    83    <span class="xdoc"> *
</span>    84    <span class="xdoc"> *  The Log calls can also be completely removed by defining the symbol
</span>    85    <span class="xdoc"> *  `xdc_runtime_Log_DISABLE_ALL`. This can be done on the compile line, e.g.
</span>    86    <span class="xdoc"> *  `-Dxdc_runtime_Log_DISABLE_ALL`. This will completely remove the `Log`
</span>    87    <span class="xdoc"> *  statements from any code compiled with this flag, regardless of the
</span>    88    <span class="xdoc"> *  application's logging configuration or your compiler's optimization
</span>    89    <span class="xdoc"> *  settings.
</span>    90    <span class="xdoc"> *
</span>    91    <span class="xdoc"> *  It is also possible to remove all logging except for
</span>    92    <span class="xdoc"> *  `{<b>@link</b> #error Log_error}`, `{<b>@link</b> #warning Log_warning}`, or
</span>    93    <span class="xdoc"> *  `{<b>@link</b> #info Log_info}` statements. This is done by first defining
</span>    94    <span class="xdoc"> *  `xdc_runtime_Log_DISABLE_ALL`, followed by defining one or more of the
</span>    95    <span class="xdoc"> *  symbols below to leave that type of logging enabled:
</span>    96    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    97    <span class="xdoc"> *  - `xdc_runtime_Log_ENABLE_ERROR`
</span>    98    <span class="xdoc"> *  - `xdc_runtime_Log_ENABLE_WARNING`
</span>    99    <span class="xdoc"> *  - `xdc_runtime_Log_ENABLE_INFO`
</span>   100    <span class="xdoc"> *  <b>@p</b>
</span>   101    <span class="xdoc"> *  For example, to disable all `Log` statements except for `Log_error`, add
</span>   102    <span class="xdoc"> *  the following to the compile line:
</span>   103    <span class="xdoc"> *  <b>@p(code)</b>
</span>   104    <span class="xdoc"> *      -Dxdc_runtime_Log_DISABLE_ALL -Dxdc_runtime_Log_ENABLE_ERROR
</span>   105    <span class="xdoc"> *  <b>@p</b>
</span>   106    <span class="xdoc"> *
</span>   107    <span class="xdoc"> *  <b>@a(Examples)</b>
</span>   108    <span class="xdoc"> *  Example 1: The following example defines a `Log` event, uses that `Log`
</span>   109    <span class="xdoc"> *  event in a module, and configures the program to generate the `Log`
</span>   110    <span class="xdoc"> *  event. In this example, both `USER1` and `USER2` bits are set in the
</span>   111    <span class="xdoc"> *  event mask. This means that if either bit is set in the module's
</span>   112    <span class="xdoc"> *  diagnostics mask, then the `Log` event will be generated.
</span>   113    <span class="xdoc"> *
</span>   114    <span class="xdoc"> *  This is a part of the XDC specification file for the `Mod` module
</span>   115    <span class="xdoc"> *  (Mod.xdc):
</span>   116    <span class="xdoc"> *
</span>   117    <span class="xdoc"> *  <b>@p(code)</b>
</span>   118    <span class="xdoc"> *  import xdc.runtime.Diags;
</span>   119    <span class="xdoc"> *  import xdc.runtime.Log;
</span>   120    <span class="xdoc"> *
</span>   121    <span class="xdoc"> *  config Log.Event L_someEvent = {
</span>   122    <span class="xdoc"> *      mask: Diags.USER1 | Diags.USER2,
</span>   123    <span class="xdoc"> *      level: Diags.LEVEL1,
</span>   124    <span class="xdoc"> *      msg: "my log event message, arg1: 0x%x, arg2: 0x%x"
</span>   125    <span class="xdoc"> *  };
</span>   126    <span class="xdoc"> *  <b>@p</b>
</span>   127    <span class="xdoc"> *
</span>   128    <span class="xdoc"> *  This is a part of the C code implementation of the Mod module:
</span>   129    <span class="xdoc"> *
</span>   130    <span class="xdoc"> *  <b>@p(code)</b>
</span>   131    <span class="xdoc"> *  #include &lt;xdc/runtime/Log.h&gt;
</span>   132    <span class="xdoc"> *  UInt x, y;
</span>   133    <span class="xdoc"> *
</span>   134    <span class="xdoc"> *  Log_write2(Mod_L_someEvent, (IArg)x, (IArg)y);
</span>   135    <span class="xdoc"> *  <b>@p</b>
</span>   136    <span class="xdoc"> *
</span>   137    <span class="xdoc"> *  The following configuration script demonstrates how the application might
</span>   138    <span class="xdoc"> *  control the `Log` statements embedded in the `Mod` module at configuration
</span>   139    <span class="xdoc"> *  time. In this case, the configuration script arranges for the `Log`
</span>   140    <span class="xdoc"> *  statements within the `Mod` module (shown above) to always generate events.
</span>   141    <span class="xdoc"> *  Without these configuration statements, no `Log` events would be generated
</span>   142    <span class="xdoc"> *  by this module.
</span>   143    <span class="xdoc"> *
</span>   144    <span class="xdoc"> *  This is part of the XDC configuration file for the application:
</span>   145    <span class="xdoc"> *
</span>   146    <span class="xdoc"> *  <b>@p(code)</b>
</span>   147    <span class="xdoc"> *  var Diags = xdc.useModule('xdc.runtime.Diags');
</span>   148    <span class="xdoc"> *  var LoggerSys = xdc.useModule('xdc.runtime.LoggerSys');
</span>   149    <span class="xdoc"> *  var Mod = xdc.useModule('my.pkg.Mod');
</span>   150    <span class="xdoc"> *  Mod.common$.diags_USER1 = Diags.ALWAYS_ON;
</span>   151    <span class="xdoc"> *  Mod.common$.logger = LoggerSys.create();
</span>   152    <span class="xdoc"> *  <b>@p</b>
</span>   153    <span class="xdoc"> *
</span>   154    <span class="xdoc"> *  <b>@p(html)</b>
</span>   155    <span class="xdoc"> *  &lt;hr /&gt;
</span>   156    <span class="xdoc"> *  <b>@p</b>
</span>   157    <span class="xdoc"> *
</span>   158    <span class="xdoc"> *  Example 2: The following XDC configuration statements turn on enter
</span>   159    <span class="xdoc"> *  and exit logging at configuration time for a module. Without any other
</span>   160    <span class="xdoc"> *  changes in the runtime code, every time a module `Mod`'s function is
</span>   161    <span class="xdoc"> *  being called or exits, an event will be logged.
</span>   162    <span class="xdoc"> *
</span>   163    <span class="xdoc"> *  <b>@p(code)</b>
</span>   164    <span class="xdoc"> *  var Diags = xdc.useModule('xdc.runtime.Diags');
</span>   165    <span class="xdoc"> *  var Mod = xdc.useModule('my.pkg.Mod');
</span>   166    <span class="xdoc"> *
</span>   167    <span class="xdoc"> *  Mod.common$.diags_ENTER = Diags.ALWAYS_ON;
</span>   168    <span class="xdoc"> *  Mod.common$.diags_EXIT = Diags.ALWAYS_ON;
</span>   169    <span class="xdoc"> *  <b>@p</b>
</span>   170    <span class="xdoc"> *
</span>   171    <span class="xdoc"> *  <b>@p(html)</b>
</span>   172    <span class="xdoc"> *  &lt;hr /&gt;
</span>   173    <span class="xdoc"> *  <b>@p</b>
</span>   174    <span class="xdoc"> *
</span>   175    <span class="xdoc"> *  Example 3: The following example configures a module to support enter and
</span>   176    <span class="xdoc"> *  exit logging, but defers the actual activation and deactivation of the
</span>   177    <span class="xdoc"> *  logging until runtime. See the `{<b>@link</b> Diags#setMask Diags_setMask()}`
</span>   178    <span class="xdoc"> *  function for details on specifying the control string.
</span>   179    <span class="xdoc"> *
</span>   180    <span class="xdoc"> *  This is a part of the XDC configuration file for the application:
</span>   181    <span class="xdoc"> *
</span>   182    <span class="xdoc"> *  <b>@p(code)</b>
</span>   183    <span class="xdoc"> *  var Diags = xdc.useModule('xdc.runtime.Diags');
</span>   184    <span class="xdoc"> *  var Mod = xdc.useModule('my.pkg.Mod');
</span>   185    <span class="xdoc"> *
</span>   186    <span class="xdoc"> *  Mod.common$.diags_ENTER = Diags.RUNTIME_OFF;
</span>   187    <span class="xdoc"> *  Mod.common$.diags_EXIT = Diags.RUNTIME_OFF;
</span>   188    <span class="xdoc"> *  <b>@p</b>
</span>   189    <span class="xdoc"> *
</span>   190    <span class="xdoc"> *  This is a part of the C code for the application:
</span>   191    <span class="xdoc"> *
</span>   192    <span class="xdoc"> *  <b>@p(code)</b>
</span>   193    <span class="xdoc"> *  // turn on enter and exit logging in the module
</span>   194    <span class="xdoc"> *  Diags_setMask("my.pkg.Mod+EX");
</span>   195    <span class="xdoc"> *
</span>   196    <span class="xdoc"> *  // turn off enter and exit logging in the module
</span>   197    <span class="xdoc"> *  Diags_setMask("my.pkg.Mod-EX");
</span>   198    <span class="xdoc"> *  <b>@p</b>
</span>   199    <span class="xdoc"> */</span>
   200    
   201    @CustomHeader
   202    
   203    <span class=key>module</span> Log {
   204    
   205        <span class="xdoc">/*!
</span>   206    <span class="xdoc">     *  ======== NUMARGS ========
</span>   207    <span class="xdoc">     *  Maximum number of arguments supported in `Log` events.
</span>   208    <span class="xdoc">     */</span>
   209        <span class=key>const</span> Int NUMARGS = 8;
   210    
   211        <span class="xdoc">/*!
</span>   212    <span class="xdoc">     *  ======== PRINTFID ========
</span>   213    <span class="xdoc">     *  The `EventId` for `Log_print()` events
</span>   214    <span class="xdoc">     */</span>
   215        <span class=key>const</span> EventId PRINTFID = 0;
   216    
   217        <span class="xdoc">/*!
</span>   218    <span class="xdoc">     *  ======== EventDesc ========
</span>   219    <span class="xdoc">     *  `Log` event descriptor
</span>   220    <span class="xdoc">     *
</span>   221    <span class="xdoc">     *  Each `Log` event is defined by a `Log` event descriptor.
</span>   222    <span class="xdoc">     *
</span>   223    <span class="xdoc">     *  The `mask` defines which bits in the module's diagnostics mask
</span>   224    <span class="xdoc">     *  enable this `Log` event.  Events "posted" via `Log_write` are only
</span>   225    <span class="xdoc">     *  written to the underlying logger if one of the mask's bits matches
</span>   226    <span class="xdoc">     *  the caller's module diagnostics settings (see
</span>   227    <span class="xdoc">     *  `{<b>@link</b> xdc.runtime.Types#common$}`).
</span>   228    <span class="xdoc">     *
</span>   229    <span class="xdoc">     *  The 'level' defines the event level of the event. While the diags
</span>   230    <span class="xdoc">     *  bits selected in the 'mask' signify the "category" of the event (e.g.
</span>   231    <span class="xdoc">     *  Entry/Exit, Analysis, Info), the 'level' field allows you to assign
</span>   232    <span class="xdoc">     *  a "priority" or "detail level" to the event relative to other events in
</span>   233    <span class="xdoc">     *  that category. There are four event levels defined by
</span>   234    <span class="xdoc">     *  '{<b>@link</b> xdc.runtime.Diags#EventLevel}'.
</span>   235    <span class="xdoc">     *
</span>   236    <span class="xdoc">     *  Filtering of events by level is handled by the ILogger implementation.
</span>   237    <span class="xdoc">     *  ILogger implementations which also implement the {<b>@link</b> IFilterLogger}
</span>   238    <span class="xdoc">     *  interface support filtering of events based on priority level.
</span>   239    <span class="xdoc">     *
</span>   240    <span class="xdoc">     *  Specifying an event level is optional. Events that don't specify a
</span>   241    <span class="xdoc">     *  level will receive Diags.LEVEL1 by default, making them the highest
</span>   242    <span class="xdoc">     *  priority and ensuring that they will not inadvertently be filtered out
</span>   243    <span class="xdoc">     *  by level-based filtering.
</span>   244    <span class="xdoc">     *
</span>   245    <span class="xdoc">     *  The `msg` defines a printf style format string that defines how to
</span>   246    <span class="xdoc">     *  render the arguments passed along the event in a `Log_write` call.
</span>   247    <span class="xdoc">     *  For a description of the allowable format strings see
</span>   248    <span class="xdoc">     *  `{<b>@link</b> #print6}`.
</span>   249    <span class="xdoc">     *
</span>   250    <span class="xdoc">     *  <b>@see</b> #write8
</span>   251    <span class="xdoc">     *  <b>@see</b> #print6
</span>   252    <span class="xdoc">     */</span>
   253        <span class=key>metaonly</span> <span class=key>struct</span> EventDesc {
   254            Diags.Mask          mask;   <span class="xdoc">/*! event enable mask */</span>
   255            Diags.EventLevel    level;  <span class="xdoc">/*! event level relative to other events */</span>
   256            String              msg;    <span class="xdoc">/*! event "printf" message format string */</span>
   257        };
   258    
   259        <span class="xdoc">/*!
</span>   260    <span class="xdoc">     *  ======== EventRec ========
</span>   261    <span class="xdoc">     *  The target representation of a recorded event
</span>   262    <span class="xdoc">     *
</span>   263    <span class="xdoc">     *  This structure defines how events are recorded on the target.
</span>   264    <span class="xdoc">     */</span>
   265        <span class=key>struct</span> EventRec {
   266            Types.Timestamp64 tstamp;   <span class="xdoc">/*! time event was written */</span>
   267            Bits32 serial;              <span class="xdoc">/*! serial number of event */</span>
   268            Types.Event evt;            <span class="xdoc">/*! target encoding of an Event */</span>
   269            IArg arg[NUMARGS];          <span class="xdoc">/*! arguments passed via Log_write/print */</span>
   270        }
   271    
   272        <span class="xdoc">/*!
</span>   273    <span class="xdoc">     *  ======== Event ========
</span>   274    <span class="xdoc">     *  `Log` event type
</span>   275    <span class="xdoc">     *
</span>   276    <span class="xdoc">     *  An `Event` is represented on the target as a 32-bit value that can
</span>   277    <span class="xdoc">     *  be decoded offline to recover the `Event` information defined in
</span>   278    <span class="xdoc">     *  a corresponding metaonly `EventDesc`.  In addition, `Event`s may be
</span>   279    <span class="xdoc">     *  decoded at runtime via methods provided in this module; see
</span>   280    <span class="xdoc">     *  `{<b>@link</b> #getMask}` and `{<b>@link</b> #getEventId}`.
</span>   281    <span class="xdoc">     *
</span>   282    <span class="xdoc">     *  When an event is "raised" a `{<b>@link</b> Types#Event Types_Event}` is
</span>   283    <span class="xdoc">     *  created which has the same event ID as the `Log_Event` but also
</span>   284    <span class="xdoc">     *  encodes the module ID of the caller.  This new event is passed to
</span>   285    <span class="xdoc">     *  the underlying `{<b>@link</b> ILogger}` module along with any arguments
</span>   286    <span class="xdoc">     *  associated with the event.
</span>   287    <span class="xdoc">     *
</span>   288    <span class="xdoc">     *  <b>@see</b> #getMask
</span>   289    <span class="xdoc">     *  <b>@see</b> #getEventId
</span>   290    <span class="xdoc">     */</span>
   291        @Encoded <span class=key>typedef</span> EventDesc Event;
   292    
   293        <span class="xdoc">/*!
</span>   294    <span class="xdoc">     *  ======== EventId ========
</span>   295    <span class="xdoc">     *  Unique ID embedded in each `{<b>@link</b> #Event}`
</span>   296    <span class="xdoc">     *
</span>   297    <span class="xdoc">     *  This ID must be used to compare two `Event`s for equality.  Event
</span>   298    <span class="xdoc">     *  ids are not guaranteed to remain constant between different
</span>   299    <span class="xdoc">     *  configurations of an application.  For example, adding a module
</span>   300    <span class="xdoc">     *  may cause the event ids of another module to change.
</span>   301    <span class="xdoc">     *
</span>   302    <span class="xdoc">     *  However, event ids declared by a module are guaranteed to be
</span>   303    <span class="xdoc">     *  consecutive values starting from the first declared
</span>   304    <span class="xdoc">     *  `{<b>@link</b> #Event Log_Event}` and increasing to the last declared
</span>   305    <span class="xdoc">     *  event.  As a result, clients of a module can efficiently test ranges
</span>   306    <span class="xdoc">     *  of events and modules can add new events, such as internal trace
</span>   307    <span class="xdoc">     *  events, without breaking clients; simply be careful to add new events
</span>   308    <span class="xdoc">     *  after any existing events in you module's `.xdc` specification.
</span>   309    <span class="xdoc">     *
</span>   310    <span class="xdoc">     *  <b>@see</b> #getEventId
</span>   311    <span class="xdoc">     *  <b>@see</b> #Event
</span>   312    <span class="xdoc">     */</span>
   313        <span class=key>typedef</span> Types.RopeId EventId;
   314    
   315        <span class="xdoc">/*!
</span>   316    <span class="xdoc">     *  ======== L_construct ========
</span>   317    <span class="xdoc">     *  Lifecycle event posted when an instance is constructed
</span>   318    <span class="xdoc">     */</span>
   319        <span class=key>config</span> Log.Event L_construct = {
   320            mask: Diags.LIFECYCLE,
   321            msg: <span class="string">"&lt;-- construct: %p('%s')"</span>
   322        };
   323    
   324        <span class="xdoc">/*!
</span>   325    <span class="xdoc">     *  ======== L_create ========
</span>   326    <span class="xdoc">     *  Lifecycle event posted when an instance is created
</span>   327    <span class="xdoc">     */</span>
   328        <span class=key>config</span> Log.Event L_create = {
   329            mask: Diags.LIFECYCLE,
   330            msg: <span class="string">"&lt;-- create: %p('%s')"</span>
   331        };
   332    
   333        <span class="xdoc">/*!
</span>   334    <span class="xdoc">     *  ======== L_destruct ========
</span>   335    <span class="xdoc">     *  Lifecycle event posted when an instance is destructed
</span>   336    <span class="xdoc">     */</span>
   337        <span class=key>config</span> Log.Event L_destruct = {
   338            mask: Diags.LIFECYCLE,
   339            msg: <span class="string">"--&gt; destruct: (%p)"</span>
   340        };
   341    
   342        <span class="xdoc">/*!
</span>   343    <span class="xdoc">     *  ======== L_delete ========
</span>   344    <span class="xdoc">     *  Lifecycle event posted when an instance is deleted
</span>   345    <span class="xdoc">     */</span>
   346        <span class=key>config</span> Log.Event L_delete = {
   347            mask: Diags.LIFECYCLE,
   348            msg: <span class="string">"--&gt; delete: (%p)"</span>
   349        };
   350    
   351        <span class="xdoc">/*!
</span>   352    <span class="xdoc">     *  ======== L_error ========
</span>   353    <span class="xdoc">     *  Error event posted by Log_errorX API
</span>   354    <span class="xdoc">     *
</span>   355    <span class="xdoc">     *  This event is marked as a STATUS event and given the priority level
</span>   356    <span class="xdoc">     *  of ERROR.
</span>   357    <span class="xdoc">     *
</span>   358    <span class="xdoc">     *  This event prints the Log call site (%$F) and a format string (%$S)
</span>   359    <span class="xdoc">     *  which is recursively formatted with any additional arguments.
</span>   360    <span class="xdoc">     */</span>
   361        <span class=key>config</span> Log.Event L_error = {
   362            mask: Diags.STATUS,
   363            level: Diags.ERROR,
   364            msg: <span class="string">"ERROR: %$F%$S"</span>
   365        };
   366    
   367        <span class="xdoc">/*!
</span>   368    <span class="xdoc">     *  ======== L_warning ========
</span>   369    <span class="xdoc">     *  Warning event posted by Log_warningX API
</span>   370    <span class="xdoc">     *
</span>   371    <span class="xdoc">     *  This event is marked as a STATUS event and given the priority level of
</span>   372    <span class="xdoc">     *  WARNING.
</span>   373    <span class="xdoc">     *
</span>   374    <span class="xdoc">     *  This event prints the Log call site (%$F) and a format string (%$S)
</span>   375    <span class="xdoc">     *  which is recursively formatted with any addition arguments.
</span>   376    <span class="xdoc">     */</span>
   377        <span class=key>config</span> xdc.runtime.Log.Event L_warning = {
   378            mask: Diags.STATUS,
   379            level: Diags.WARNING,
   380            msg: <span class="string">"WARNING: %$F%$S"</span>
   381        };
   382    
   383        <span class="xdoc">/*!
</span>   384    <span class="xdoc">     *  ======== L_info ========
</span>   385    <span class="xdoc">     *  Info event posted by Log_infoX API
</span>   386    <span class="xdoc">     *
</span>   387    <span class="xdoc">     *  This event is marked as an INFO event. The event priority is not
</span>   388    <span class="xdoc">     *  specified in the event definition. Rather, it is specified as an
</span>   389    <span class="xdoc">     *  argument to the Log_infoX APIs.
</span>   390    <span class="xdoc">     *
</span>   391    <span class="xdoc">     *  This event prints the Log call site (%$F) and a format string (%$S)
</span>   392    <span class="xdoc">     *  which is recursively formatted with any addition arguments.
</span>   393    <span class="xdoc">     */</span>
   394        <span class=key>config</span> xdc.runtime.Log.Event L_info = {
   395            mask: Diags.INFO,
   396            msg: <span class="string">"%$F%$S"</span>
   397        };
   398    
   399        <span class="xdoc">/*!
</span>   400    <span class="xdoc">     *  ======== L_start ========
</span>   401    <span class="xdoc">     *  Benchmark event used to log the start of an operation
</span>   402    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   403    <span class="xdoc">     *
</span>   404    <span class="xdoc">     * <b>@a(Example)</b>
</span>   405    <span class="xdoc">     *   The following C code shows how to log a simple
</span>   406    <span class="xdoc">     *   benchmark 'start' event along with a user-specified
</span>   407    <span class="xdoc">     *   format string describing the event.
</span>   408    <span class="xdoc">     *
</span>   409    <span class="xdoc">     *  <b>@p(code)</b>
</span>   410    <span class="xdoc">     *  #include &lt;xdc/runtime/Log.h&gt;
</span>   411    <span class="xdoc">     *  ...
</span>   412    <span class="xdoc">     *  Log_write2(Log_L_start, (IArg)"My benchmark event", (IArg)myUniqueId);
</span>   413    <span class="xdoc">     *  Log_write2(Log_L_stop, (IArg)"My benchmark event", (IArg)myUniqueId);
</span>   414    <span class="xdoc">     *  <b>@p</b>
</span>   415    <span class="xdoc">     *  <b>@param(fmt)</b>     a constant string that provides format specifiers for up to 6 additional parameters
</span>   416    <span class="xdoc">     *  <b>@param(id)</b>      a unique ID used to match benchmark start and stop events
</span>   417    <span class="xdoc">     */</span>
   418        <span class=key>config</span> xdc.runtime.Log.Event L_start = {
   419            mask: Diags.ANALYSIS,
   420            msg: <span class="string">"Start: %$S"</span>};
   421    
   422        <span class="xdoc">/*!
</span>   423    <span class="xdoc">     *  ======== L_stop ========
</span>   424    <span class="xdoc">     *  Benchmark event used to log the end of an operation
</span>   425    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   426    <span class="xdoc">     *
</span>   427    <span class="xdoc">     *  <b>@a(Example)</b>
</span>   428    <span class="xdoc">     *   The following C code shows how to log a simple
</span>   429    <span class="xdoc">     *   benchmark 'stop' event along with a user-specified
</span>   430    <span class="xdoc">     *   format string describing the event.
</span>   431    <span class="xdoc">     *
</span>   432    <span class="xdoc">     *  <b>@p(code)</b>
</span>   433    <span class="xdoc">     *  #include &lt;xdc/runtime/Log.h&gt;
</span>   434    <span class="xdoc">     *  ...
</span>   435    <span class="xdoc">     *  Log_write2(Log_L_start, (IArg)"My benchmark event", (IArg)myUniqueId);
</span>   436    <span class="xdoc">     *  Log_write2(Log_L_stop, (IArg)"My benchmark event", (IArg)myUniqueId);
</span>   437    <span class="xdoc">     *  <b>@p</b>
</span>   438    <span class="xdoc">     *  <b>@param(fmt)</b>     a constant string that provides format specifiers for up to 6 additional parameters
</span>   439    <span class="xdoc">     *  <b>@param(id)</b>      a unique ID used to match benchmark start and stop events
</span>   440    <span class="xdoc">     */</span>
   441        <span class=key>config</span> xdc.runtime.Log.Event L_stop = {
   442            mask: Diags.ANALYSIS,
   443            msg: <span class="string">"Stop: %$S"</span>};
   444    
   445        <span class="xdoc">/*!
</span>   446    <span class="xdoc">     *  ======== L_startInstance ========
</span>   447    <span class="xdoc">     *  Benchmark event used to log the start of an operation instance
</span>   448    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   449    <span class="xdoc">     *
</span>   450    <span class="xdoc">     *  Event parameter provides instance data to differentiate
</span>   451    <span class="xdoc">     *  between multiple instances that can run in parallel.
</span>   452    <span class="xdoc">     *
</span>   453    <span class="xdoc">     *  <b>@a(Example)</b>
</span>   454    <span class="xdoc">     *   The following C code shows how to log a benchmark
</span>   455    <span class="xdoc">     *   'startInstance' event along with a user-specified
</span>   456    <span class="xdoc">     *   instance identifier and a format string describing the event.
</span>   457    <span class="xdoc">     *
</span>   458    <span class="xdoc">     *  <b>@p(code)</b>
</span>   459    <span class="xdoc">     *  #include &lt;xdc/runtime/Log.h&gt;
</span>   460    <span class="xdoc">     *  ...
</span>   461    <span class="xdoc">     *  Log_write3(Log_L_startInstance, (IArg)"My benchmark event", (IArg)uniqueId, (IArg)instId);
</span>   462    <span class="xdoc">     *  ...
</span>   463    <span class="xdoc">     *  Log_write3(Log_L_stopInstance, (IArg)"My benchmark event", (IArg)uniqueId, (IArg)instId);
</span>   464    <span class="xdoc">     *  <b>@p</b>
</span>   465    <span class="xdoc">     *  <b>@param(fmt)</b>     a constant string that provides format specifiers for up to 6 additional parameters
</span>   466    <span class="xdoc">     *  <b>@param(id)</b>      a unique ID used to match benchmark start and stop events
</span>   467    <span class="xdoc">     *  <b>@param(instId)</b>  a unique instance ID that can be used to match and instance
</span>   468    <span class="xdoc">     */</span>
   469        <span class=key>config</span> xdc.runtime.Log.Event L_startInstance = {
   470            mask: Diags.ANALYSIS,
   471            msg: <span class="string">"StartInstance: %$S"</span>
   472        };
   473    
   474        <span class="xdoc">/*!
</span>   475    <span class="xdoc">     *  ======== L_stopInstance ========
</span>   476    <span class="xdoc">     *  Benchmark event used to log the end of an operation instance
</span>   477    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   478    <span class="xdoc">     *
</span>   479    <span class="xdoc">     *  Event parameter provides instance data to differentiate
</span>   480    <span class="xdoc">     *  between multiple instances that can run in parallel.
</span>   481    <span class="xdoc">     *
</span>   482    <span class="xdoc">     * <b>@a(Example)</b>
</span>   483    <span class="xdoc">     *   The following C code shows how to log a benchmark
</span>   484    <span class="xdoc">     *   'stopInstance' event along with a user-specified
</span>   485    <span class="xdoc">     *   instance identifier and a format string describing the event.
</span>   486    <span class="xdoc">     *
</span>   487    <span class="xdoc">     *  <b>@p(code)</b>
</span>   488    <span class="xdoc">     *  #include &lt;xdc/runtime/Log.h&gt;
</span>   489    <span class="xdoc">     *  ...
</span>   490    <span class="xdoc">     *  Log_write3(Log_L_startInstance, (IArg)"My benchmark event", (IArg)uniqueId, (IArg)instId);
</span>   491    <span class="xdoc">     *  ...
</span>   492    <span class="xdoc">     *  Log_write3(Log_L_stopInstance, (IArg)"My benchmark event", (IArg)uniqueId, (IArg)instId);
</span>   493    <span class="xdoc">     *  <b>@p</b>
</span>   494    <span class="xdoc">     *  <b>@param(fmt)</b>     a constant string that provides format specifiers for up to 6 additional parameters
</span>   495    <span class="xdoc">     *  <b>@param(id)</b>      a unique ID used to match benchmark start and stop events
</span>   496    <span class="xdoc">     *  <b>@param(instId)</b>  a unique instance ID that can be used to match and instance
</span>   497    <span class="xdoc">     */</span>
   498        <span class=key>config</span> xdc.runtime.Log.Event L_stopInstance = {
   499            mask: Diags.ANALYSIS,
   500            msg: <span class="string">"StopInstance: %$S"</span>
   501        };
   502    
   503        <span class="xdoc">/*!
</span>   504    <span class="xdoc">     *  ======== getMask ========
</span>   505    <span class="xdoc">     *  Get the `Diags` mask for the specified (encoded) event
</span>   506    <span class="xdoc">     *
</span>   507    <span class="xdoc">     *  <b>@param(evt)</b> the `Log` event encoding a mask and event ID
</span>   508    <span class="xdoc">     *
</span>   509    <span class="xdoc">     *  <b>@a(returns)</b> `Diags` mask for the specified event
</span>   510    <span class="xdoc">     */</span>
   511        @Macro Diags.Mask getMask(Event evt);
   512    
   513        <span class="xdoc">/*!
</span>   514    <span class="xdoc">     *  ======== getRope ========
</span>   515    <span class="xdoc">     *  Get RopeId of the Event.msg for the specified (encoded) event
</span>   516    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   517    <span class="xdoc">     */</span>
   518        @Macro Text.RopeId getRope(Event evt);
   519    
   520        <span class="xdoc">/*!
</span>   521    <span class="xdoc">     *  ======== getEventId ========
</span>   522    <span class="xdoc">     *  Get event ID of the specified (encoded) event
</span>   523    <span class="xdoc">     *
</span>   524    <span class="xdoc">     *  This method is used to compare "known" `Log` events with
</span>   525    <span class="xdoc">     *  "raised" `{<b>@link</b> Types#Event Types_Event}`.
</span>   526    <span class="xdoc">     *
</span>   527    <span class="xdoc">     *  <b>@param(evt)</b> the `Log` event encoding a mask and event ID
</span>   528    <span class="xdoc">     *
</span>   529    <span class="xdoc">     *  <b>@a(returns)</b> event ID of the specified event
</span>   530    <span class="xdoc">     *
</span>   531    <span class="xdoc">     *  <b>@see</b> Types#getEventId
</span>   532    <span class="xdoc">     */</span>
   533        @Macro EventId getEventId(Event evt);
   534    
   535        <span class="xdoc">/*!
</span>   536    <span class="xdoc">     *  ======== print0 ========
</span>   537    <span class="xdoc">     *  Generate a `Log` "print event" with 0 arguments
</span>   538    <span class="xdoc">     *
</span>   539    <span class="xdoc">     *  <b>@see</b> #print6
</span>   540    <span class="xdoc">     */</span>
   541        @Macro Void print0(Diags.Mask mask, String fmt);
   542    
   543        <span class="xdoc">/*!
</span>   544    <span class="xdoc">     *  ======== print1 ========
</span>   545    <span class="xdoc">     *  Generate a `Log` "print event" with 1 argument
</span>   546    <span class="xdoc">     *
</span>   547    <span class="xdoc">     *  <b>@see</b> #print6
</span>   548    <span class="xdoc">     */</span>
   549        @Macro Void print1(Diags.Mask mask, String fmt, IArg a1);
   550    
   551        <span class="xdoc">/*!
</span>   552    <span class="xdoc">     *  ======== print2 ========
</span>   553    <span class="xdoc">     *  Generate a `Log` "print event" with 2 arguments
</span>   554    <span class="xdoc">     *
</span>   555    <span class="xdoc">     *  <b>@see</b> #print6
</span>   556    <span class="xdoc">     */</span>
   557        @Macro Void print2(Diags.Mask mask, String fmt, IArg a1, IArg a2);
   558    
   559        <span class="xdoc">/*!
</span>   560    <span class="xdoc">     *  ======== print3 ========
</span>   561    <span class="xdoc">     *  Generate a `Log` "print event" with 3 arguments
</span>   562    <span class="xdoc">     *
</span>   563    <span class="xdoc">     *  <b>@see</b> #print6
</span>   564    <span class="xdoc">     */</span>
   565        @Macro Void print3(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3);
   566    
   567        <span class="xdoc">/*!
</span>   568    <span class="xdoc">     *  ======== print4 ========
</span>   569    <span class="xdoc">     *  Generate a `Log` "print event" with 4 arguments
</span>   570    <span class="xdoc">     *
</span>   571    <span class="xdoc">     *  <b>@see</b> #print6
</span>   572    <span class="xdoc">     */</span>
   573        @Macro Void print4(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3,
   574            IArg a4);
   575    
   576        <span class="xdoc">/*!
</span>   577    <span class="xdoc">     *  ======== print5 ========
</span>   578    <span class="xdoc">     *  Generate a `Log` "print event" with 5 arguments
</span>   579    <span class="xdoc">     *
</span>   580    <span class="xdoc">     *  <b>@see</b> #print6
</span>   581    <span class="xdoc">     */</span>
   582        @Macro Void print5(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3,
   583            IArg a4, IArg a5);
   584    
   585        <span class="xdoc">/*!
</span>   586    <span class="xdoc">     *  ======== print6 ========
</span>   587    <span class="xdoc">     *  Generate a `Log` "print event" with 6 arguments
</span>   588    <span class="xdoc">     *
</span>   589    <span class="xdoc">     *  As a convenience to C (as well as assembly language) programmers,
</span>   590    <span class="xdoc">     *  the `Log` module provides a variation of the ever-popular `printf`
</span>   591    <span class="xdoc">     *  function.
</span>   592    <span class="xdoc">     *  The `print[0-6]` functions generate a `Log` "print event" and route
</span>   593    <span class="xdoc">     *  it to the current module's logger.
</span>   594    <span class="xdoc">     *
</span>   595    <span class="xdoc">     *  The arguments passed to `print[0-6]` may be characters, integers,
</span>   596    <span class="xdoc">     *  strings, or pointers.  However, because the declared type of the
</span>   597    <span class="xdoc">     *  arguments is `{<b>@link</b> xdc IArg}`, all pointer arguments must be cast
</span>   598    <span class="xdoc">     *  to an `IArg` type.  `IArg` is an integral type large enough to hold
</span>   599    <span class="xdoc">     *  any pointer or an `int`.  So, casting a pointer to an `IArg` does
</span>   600    <span class="xdoc">     *  not cause any loss of information and C's normal integer conversions
</span>   601    <span class="xdoc">     *  make the cast unnecessary for integral arguments.
</span>   602    <span class="xdoc">     *
</span>   603    <span class="xdoc">     *  The format string can use the following conversion characters.
</span>   604    <span class="xdoc">     *  However, it is important to recall that all arguments referenced by
</span>   605    <span class="xdoc">     *  these conversion characters have been converted to an `IArg`
</span>   606    <span class="xdoc">     *  prior to conversion; so, the use of "length modifiers" should be
</span>   607    <span class="xdoc">     *  avoided.
</span>   608    <span class="xdoc">     *
</span>   609    <span class="xdoc">     *  <b>@p(code)</b>
</span>   610    <span class="xdoc">     *  Conversion Character    Description
</span>   611    <span class="xdoc">     *  ------------------------------------------------
</span>   612    <span class="xdoc">     *  %c                      Character
</span>   613    <span class="xdoc">     *  %d                      Signed integer
</span>   614    <span class="xdoc">     *  %u                      Unsigned integer
</span>   615    <span class="xdoc">     *  %x                      Unsigned hexadecimal integer
</span>   616    <span class="xdoc">     *  %o                      Unsigned octal integer
</span>   617    <span class="xdoc">     *  %s                      Character string
</span>   618    <span class="xdoc">     *  %p                      Pointer
</span>   619    <span class="xdoc">     *  %f                      Single precision floating point (float)
</span>   620    <span class="xdoc">     *  <b>@p</b>
</span>   621    <span class="xdoc">     *
</span>   622    <span class="xdoc">     *  Format strings, while very convenient, are a well known source of
</span>   623    <span class="xdoc">     *  portability problems: each format specification must precisely match
</span>   624    <span class="xdoc">     *  the types of the arguments passed. Underlying "printf" functions use
</span>   625    <span class="xdoc">     *  the format string to determine how far to advance through their
</span>   626    <span class="xdoc">     *  argument list. For targets where pointer types and integers are the
</span>   627    <span class="xdoc">     *  same size there are no problems.  However, suppose a target's pointer
</span>   628    <span class="xdoc">     *  type is larger than its integer type. In this case, because integer
</span>   629    <span class="xdoc">     *  arguments are widened to be of type `IArg`, a format specification of
</span>   630    <span class="xdoc">     *  "%d" causes an underlying `printf()` implementation to read the
</span>   631    <span class="xdoc">     *  extended part of the integer argument as part of the next argument(!).
</span>   632    <span class="xdoc">     *
</span>   633    <span class="xdoc">     *  To get around this problem and still allow the use of "natural"
</span>   634    <span class="xdoc">     *  format specifications (e.g., `%d` and `%x` with optional width
</span>   635    <span class="xdoc">     *  specifications), `{<b>@link</b> System#aprintf()}` is used which assumes
</span>   636    <span class="xdoc">     *  that all arguments have been widened to be of type `IArg`.
</span>   637    <span class="xdoc">     *
</span>   638    <span class="xdoc">     *  See `{<b>@link</b> System#printf}` for complete details.
</span>   639    <span class="xdoc">     *
</span>   640    <span class="xdoc">     *  The `%f` format specifier is used to print a single precision float
</span>   641    <span class="xdoc">     *  value. Note that `%f` assumes that sizeof(Float) &lt;= sizeof(IArg).
</span>   642    <span class="xdoc">     *  Most clients that interpret float values expect that they are
</span>   643    <span class="xdoc">     *  represented in IEEE 754 floating point format. Therefore, it is
</span>   644    <span class="xdoc">     *  recommended that the float values be converted into that format prior
</span>   645    <span class="xdoc">     *  to supplying the values to `Log` functions in cases where targets do
</span>   646    <span class="xdoc">     *  not generate the float values in IEEE 754 floating point format by
</span>   647    <span class="xdoc">     *  default.
</span>   648    <span class="xdoc">     *
</span>   649    <span class="xdoc">     *  The first argument to a `Log_print` call is the diags category to be
</span>   650    <span class="xdoc">     *  associated with the event.
</span>   651    <span class="xdoc">     *
</span>   652    <span class="xdoc">     *  It is also possible to associate an event level with the event to
</span>   653    <span class="xdoc">     *  enable filtering of events based on event level. Conceptually, it is
</span>   654    <span class="xdoc">     *  best to regard the event level as completely separate from the event's
</span>   655    <span class="xdoc">     *  diags category; however, the priority value actually occupies a part
</span>   656    <span class="xdoc">     *  of the diags mask. For this reason, it is possible to specify an event
</span>   657    <span class="xdoc">     *  level by OR'ing the level with the diags mask. For example, to print
</span>   658    <span class="xdoc">     *  an `Diags_INFO` event of `Diags_LEVEL2`, you'd simply write:
</span>   659    <span class="xdoc">     *  (Diags_INFO | Diags_LEVEL2)
</span>   660    <span class="xdoc">     *
</span>   661    <span class="xdoc">     *  Specifying an event level is optional. `Log_print` calls which do not
</span>   662    <span class="xdoc">     *  specify a level will receive the highest priority by default.
</span>   663    <span class="xdoc">     *
</span>   664    <span class="xdoc">     *  <b>@param(mask)</b>    enable bits and optional detail level for this event
</span>   665    <span class="xdoc">     *  <b>@param(fmt)</b>     a `printf` style format string
</span>   666    <span class="xdoc">     *  <b>@param(a1)</b>      value for first format conversion character
</span>   667    <span class="xdoc">     *  <b>@param(a2)</b>      value for second format conversion character
</span>   668    <span class="xdoc">     *  <b>@param(a3)</b>      value for third format conversion character
</span>   669    <span class="xdoc">     *  <b>@param(a4)</b>      value for fourth format conversion character
</span>   670    <span class="xdoc">     *  <b>@param(a5)</b>      value for fifth format conversion character
</span>   671    <span class="xdoc">     *  <b>@param(a6)</b>      value for sixth format conversion character
</span>   672    <span class="xdoc">     *
</span>   673    <span class="xdoc">     *  <b>@a(Examples)</b>
</span>   674    <span class="xdoc">     *  The following example demonstrates a typical usage.
</span>   675    <span class="xdoc">     *  <b>@p(code)</b>
</span>   676    <span class="xdoc">     *  String  list[];
</span>   677    <span class="xdoc">     *  UInt    i;
</span>   678    <span class="xdoc">     *
</span>   679    <span class="xdoc">     *  Log_print2(Diags_USER2, "list[%u] = %s\n", i, (IArg)list[i]);
</span>   680    <span class="xdoc">     *  <b>@p</b>
</span>   681    <span class="xdoc">     *  Note that the `IArg` cast above is only necessary for pointer
</span>   682    <span class="xdoc">     *  arguments; C's normal parameter conversions implicitly convert
</span>   683    <span class="xdoc">     *  integral arguments.
</span>   684    <span class="xdoc">     *
</span>   685    <span class="xdoc">     *  To simplify the conversion from `float` arguments to `IArg`,
</span>   686    <span class="xdoc">     *  the standard header `xdc/std.h` provides a macro, named floatToArg(),
</span>   687    <span class="xdoc">     *  to do this conversion in a type safe manner.  So, the following
</span>   688    <span class="xdoc">     *  statement will print "`float = 2.3456`":
</span>   689    <span class="xdoc">     *  <b>@p(code)</b>
</span>   690    <span class="xdoc">     *    Log_print1(Diags_USER1, "float = %f", floatToArg(2.34567));
</span>   691    <span class="xdoc">     *  <b>@p</b>
</span>   692    <span class="xdoc">     *
</span>   693    <span class="xdoc">     *  Note that, if you are formatting events on the target, you must
</span>   694    <span class="xdoc">     *  also add support for floating point to ASCII conversion to
</span>   695    <span class="xdoc">     *  `{<b>@link</b> System#printf}`; for more information, see the
</span>   696    <span class="xdoc">     *  `{<b>@link</b> System#extendedFormats}` reference documenation.  For example:
</span>   697    <span class="xdoc">     *  <b>@p(code)</b>
</span>   698    <span class="xdoc">     *      var System = xdc.useModule('xdc.runtime.System');
</span>   699    <span class="xdoc">     *      System.extendedFormats = "%f";
</span>   700    <span class="xdoc">     *  <b>@p</b>
</span>   701    <span class="xdoc">     */</span>
   702        @Macro Void print6(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3,
   703            IArg a4, IArg a5, IArg a6);
   704    
   705        <span class="xdoc">/*!
</span>   706    <span class="xdoc">     *  ======== error0 ========
</span>   707    <span class="xdoc">     *  Generate a `Log` "error event" with 0 arguments
</span>   708    <span class="xdoc">     *
</span>   709    <span class="xdoc">     *  <b>@see</b> #error5
</span>   710    <span class="xdoc">     */</span>
   711        @Macro Void error0(String fmt);
   712    
   713        <span class="xdoc">/*!
</span>   714    <span class="xdoc">     *  ======== error1 ========
</span>   715    <span class="xdoc">     *  Generate a `Log` "error event" with 1 argument
</span>   716    <span class="xdoc">     *
</span>   717    <span class="xdoc">     *  <b>@see</b> #error5
</span>   718    <span class="xdoc">     */</span>
   719        @Macro Void error1(String fmt, IArg a1);
   720    
   721        <span class="xdoc">/*!
</span>   722    <span class="xdoc">     *  ======== error2 ========
</span>   723    <span class="xdoc">     *  Generate a `Log` "error event" with 2 arguments
</span>   724    <span class="xdoc">     *
</span>   725    <span class="xdoc">     *  <b>@see</b> #error5
</span>   726    <span class="xdoc">     */</span>
   727        @Macro Void error2(String fmt, IArg a1, IArg a2);
   728    
   729        <span class="xdoc">/*!
</span>   730    <span class="xdoc">     *  ======== error3 ========
</span>   731    <span class="xdoc">     *  Generate a `Log` "error event" with 3 arguments
</span>   732    <span class="xdoc">     *
</span>   733    <span class="xdoc">     *  <b>@see</b> #error5
</span>   734    <span class="xdoc">     */</span>
   735        @Macro Void error3(String fmt, IArg a1, IArg a2, IArg a3);
   736    
   737        <span class="xdoc">/*!
</span>   738    <span class="xdoc">     *  ======== error4 ========
</span>   739    <span class="xdoc">     *  Generate a `Log` "error event" with 4 arguments
</span>   740    <span class="xdoc">     *
</span>   741    <span class="xdoc">     *  <b>@see</b> #error5
</span>   742    <span class="xdoc">     */</span>
   743        @Macro Void error4(String fmt, IArg a1, IArg a2, IArg a3,
   744            IArg a4);
   745    
   746        <span class="xdoc">/*!
</span>   747    <span class="xdoc">     *  ======== error5 ========
</span>   748    <span class="xdoc">     *  Generate a `Log` "error event" with 5 arguments
</span>   749    <span class="xdoc">     *
</span>   750    <span class="xdoc">     *  The Log_error APIs are intended to allow users to easily log error
</span>   751    <span class="xdoc">     *  events in their code. Similar to the Log_print APIs, Log_error does not
</span>   752    <span class="xdoc">     *  require that you define an event. You simply pass an informative error
</span>   753    <span class="xdoc">     *  string which can optionally be formatted with additional arguments. The
</span>   754    <span class="xdoc">     *  error is logged with the predefined event {<b>@link</b> #L_error}.
</span>   755    <span class="xdoc">     *
</span>   756    <span class="xdoc">     *  Log_error prepends a string to the message which identifies it as an
</span>   757    <span class="xdoc">     *  ERROR and specifies the filename and line number of the Log_error call
</span>   758    <span class="xdoc">     *  site. A simple example:
</span>   759    <span class="xdoc">     *
</span>   760    <span class="xdoc">     *  <b>@p(code)</b>
</span>   761    <span class="xdoc">     *  Log_error0("Invalid argument");
</span>   762    <span class="xdoc">     *  <b>@p</b>
</span>   763    <span class="xdoc">     *  This event will be formatted as (assuming that the above call was line
</span>   764    <span class="xdoc">     *  35 of "MyCode.c")
</span>   765    <span class="xdoc">     *  <b>@p(code)</b>
</span>   766    <span class="xdoc">     *  ERROR at "MyCode.c", line 35: Invalid argument
</span>   767    <span class="xdoc">     *  <b>@p</b>
</span>   768    <span class="xdoc">     *
</span>   769    <span class="xdoc">     *  Users may provide additional information in the error event, such as
</span>   770    <span class="xdoc">     *  a predefined error code or details of the error. These additional
</span>   771    <span class="xdoc">     *  values will be used to format the string passed to Log_error.
</span>   772    <span class="xdoc">     *  <b>@see</b> #print6 for information about format strings.
</span>   773    <span class="xdoc">     *
</span>   774    <span class="xdoc">     *  Log_error does not use a variable length argument list--you must call
</span>   775    <span class="xdoc">     *  the appropriate Log_errorX API based on the number of arguments.
</span>   776    <span class="xdoc">     *
</span>   777    <span class="xdoc">     *  <b>@param(fmt)</b>      a reference to a constant error string / fmt string
</span>   778    <span class="xdoc">     *  <b>@param(a1)</b>       value for an additional parameter (e.g. an error code)
</span>   779    <span class="xdoc">     *  <b>@param(a2)</b>       value for an additional parameter
</span>   780    <span class="xdoc">     *  <b>@param(a3)</b>       value for an additional parameter
</span>   781    <span class="xdoc">     *  <b>@param(a4)</b>       value for an additional parameter
</span>   782    <span class="xdoc">     *  <b>@param(a5)</b>       value for an additional parameter
</span>   783    <span class="xdoc">     *
</span>   784    <span class="xdoc">     *  <b>@a(Examples)</b>
</span>   785    <span class="xdoc">     *  The following example demonstrates a typical usage.
</span>   786    <span class="xdoc">     *  <b>@p(code)</b>
</span>   787    <span class="xdoc">     *  Int myArg;
</span>   788    <span class="xdoc">     *
</span>   789    <span class="xdoc">     *  Log_error1("Invalid argument: %d", myArg);
</span>   790    <span class="xdoc">     *  <b>@p</b>
</span>   791    <span class="xdoc">     *  The above event is formatted as, for example:
</span>   792    <span class="xdoc">     *  <b>@p(code)</b>
</span>   793    <span class="xdoc">     *  ERROR: "MyCode.c", line 35: Invalid argument: -1
</span>   794    <span class="xdoc">     *  <b>@p</b>
</span>   795    <span class="xdoc">     */</span>
   796        @Macro Void error5(String fmt, IArg a1, IArg a2, IArg a3,
   797            IArg a4, IArg a5);
   798    
   799        <span class="xdoc">/*!
</span>   800    <span class="xdoc">     *  ======== warning0 ========
</span>   801    <span class="xdoc">     *  Generate a `Log` "warning event" with 0 arguments
</span>   802    <span class="xdoc">     *
</span>   803    <span class="xdoc">     *  <b>@see</b> #warning5
</span>   804    <span class="xdoc">     */</span>
   805        @Macro Void warning0(String fmt);
   806    
   807        <span class="xdoc">/*!
</span>   808    <span class="xdoc">     *  ======== warning1 ========
</span>   809    <span class="xdoc">     *  Generate a `Log` "warning event" with 1 argument
</span>   810    <span class="xdoc">     *
</span>   811    <span class="xdoc">     *  <b>@see</b> #warning5
</span>   812    <span class="xdoc">     */</span>
   813        @Macro Void warning1(String fmt, IArg a1);
   814    
   815        <span class="xdoc">/*!
</span>   816    <span class="xdoc">     *  ======== warning2 ========
</span>   817    <span class="xdoc">     *  Generate a `Log` "warning event" with 2 arguments
</span>   818    <span class="xdoc">     *
</span>   819    <span class="xdoc">     *  <b>@see</b> #warning5
</span>   820    <span class="xdoc">     */</span>
   821        @Macro Void warning2(String fmt, IArg a1, IArg a2);
   822    
   823        <span class="xdoc">/*!
</span>   824    <span class="xdoc">     *  ======== warning3 ========
</span>   825    <span class="xdoc">     *  Generate a `Log` "warning event" with 3 arguments
</span>   826    <span class="xdoc">     *
</span>   827    <span class="xdoc">     *  <b>@see</b> #warning5
</span>   828    <span class="xdoc">     */</span>
   829        @Macro Void warning3(String fmt, IArg a1, IArg a2, IArg a3);
   830    
   831        <span class="xdoc">/*!
</span>   832    <span class="xdoc">     *  ======== warning4 ========
</span>   833    <span class="xdoc">     *  Generate a `Log` "warning event" with 4 arguments
</span>   834    <span class="xdoc">     *
</span>   835    <span class="xdoc">     *  <b>@see</b> #warning5
</span>   836    <span class="xdoc">     */</span>
   837        @Macro Void warning4(String fmt, IArg a1, IArg a2, IArg a3,
   838            IArg a4);
   839    
   840        <span class="xdoc">/*!
</span>   841    <span class="xdoc">     *  ======== warning5 ========
</span>   842    <span class="xdoc">     *  Generate a `Log` "warning event" with 5 arguments
</span>   843    <span class="xdoc">     *
</span>   844    <span class="xdoc">     *  The Log_warning APIs provide the same features as the Log_error APIs,
</span>   845    <span class="xdoc">     *  but are used to specifically log "warning" events.
</span>   846    <span class="xdoc">     *  <b>@see</b> #error5
</span>   847    <span class="xdoc">     *
</span>   848    <span class="xdoc">     *  The Log_warning APIs are equivalent to the Log_error APIs except that
</span>   849    <span class="xdoc">     *  they use the predefined {<b>@link</b> #L_warning} event. Log_warning prepends
</span>   850    <span class="xdoc">     *  a string to the message which identifies it as a WARNING and specifies
</span>   851    <span class="xdoc">     *  the filename and line number of the Log_warning call site.
</span>   852    <span class="xdoc">     *
</span>   853    <span class="xdoc">     *  <b>@param(fmt)</b>     reference to a constant warning string / fmt string
</span>   854    <span class="xdoc">     *  <b>@param(a1)</b>      value for an additional parameter (e.g. a warning code)
</span>   855    <span class="xdoc">     *  <b>@param(a2)</b>      value for an additional parameter
</span>   856    <span class="xdoc">     *  <b>@param(a3)</b>      value for an additional parameter
</span>   857    <span class="xdoc">     *  <b>@param(a4)</b>      value for an additional parameter
</span>   858    <span class="xdoc">     *  <b>@param(a5)</b>      value for an additional parameter
</span>   859    <span class="xdoc">     *
</span>   860    <span class="xdoc">     *  <b>@a(Examples)</b>
</span>   861    <span class="xdoc">     *  The following example demonstrates a typical usage.
</span>   862    <span class="xdoc">     *  <b>@p(code)</b>
</span>   863    <span class="xdoc">     *  Int myArg;
</span>   864    <span class="xdoc">     *
</span>   865    <span class="xdoc">     *  Log_warning1("Value may be too high: %d", myArg);
</span>   866    <span class="xdoc">     *  <b>@p</b>
</span>   867    <span class="xdoc">     *  The above event is formatted as:
</span>   868    <span class="xdoc">     *  <b>@p(code)</b>
</span>   869    <span class="xdoc">     *  WARNING: "MyCode.c", line 50: Value may be too high: 4096
</span>   870    <span class="xdoc">     *  <b>@p</b>
</span>   871    <span class="xdoc">     */</span>
   872        @Macro Void warning5(String fmt, IArg a1, IArg a2, IArg a3,
   873            IArg a4, IArg a5);
   874    
   875        <span class="xdoc">/*!
</span>   876    <span class="xdoc">     *  ======== info0 ========
</span>   877    <span class="xdoc">     *  Generate a `Log` "info event" with 0 arguments
</span>   878    <span class="xdoc">     *
</span>   879    <span class="xdoc">     *  <b>@see</b> #info5
</span>   880    <span class="xdoc">     */</span>
   881        @Macro Void info0(String fmt);
   882    
   883        <span class="xdoc">/*!
</span>   884    <span class="xdoc">     *  ======== info1 ========
</span>   885    <span class="xdoc">     *  Generate a `Log` "info event" with 1 argument
</span>   886    <span class="xdoc">     *
</span>   887    <span class="xdoc">     *  <b>@see</b> #info5
</span>   888    <span class="xdoc">     */</span>
   889        @Macro Void info1(String fmt, IArg a1);
   890    
   891        <span class="xdoc">/*!
</span>   892    <span class="xdoc">     *  ======== info2 ========
</span>   893    <span class="xdoc">     *  Generate a `Log` "info event" with 2 arguments
</span>   894    <span class="xdoc">     *
</span>   895    <span class="xdoc">     *  <b>@see</b> #info5
</span>   896    <span class="xdoc">     */</span>
   897        @Macro Void info2(String fmt, IArg a1, IArg a2);
   898    
   899        <span class="xdoc">/*!
</span>   900    <span class="xdoc">     *  ======== info3 ========
</span>   901    <span class="xdoc">     *  Generate a `Log` "info event" with 3 arguments
</span>   902    <span class="xdoc">     *
</span>   903    <span class="xdoc">     *  <b>@see</b> #info5
</span>   904    <span class="xdoc">     */</span>
   905        @Macro Void info3(String fmt, IArg a1, IArg a2, IArg a3);
   906    
   907        <span class="xdoc">/*!
</span>   908    <span class="xdoc">     *  ======== info4 ========
</span>   909    <span class="xdoc">     *  Generate a `Log` "info event" with 4 arguments
</span>   910    <span class="xdoc">     *
</span>   911    <span class="xdoc">     *  <b>@see</b> #info5
</span>   912    <span class="xdoc">     */</span>
   913        @Macro Void info4(String fmt, IArg a1, IArg a2, IArg a3, IArg a4);
   914    
   915        <span class="xdoc">/*!
</span>   916    <span class="xdoc">     *  ======== info5 ========
</span>   917    <span class="xdoc">     *  Generate a `Log` "info event" with 5 arguments
</span>   918    <span class="xdoc">     *
</span>   919    <span class="xdoc">     *  The Log_info APIs are provided for easily logging generic
</span>   920    <span class="xdoc">     *  "informational" events with call site information. They are similar to
</span>   921    <span class="xdoc">     *  the Log_print APIs in that they do not require you to define an event--
</span>   922    <span class="xdoc">     *  you simply pass an informative printf-style string which can optionally
</span>   923    <span class="xdoc">     *  be formatted with additional arguments. The info record is logged with
</span>   924    <span class="xdoc">     *  the predefined event '{<b>@link</b> #L_info}'.
</span>   925    <span class="xdoc">     *
</span>   926    <span class="xdoc">     *  The Log_info APIs log the {<b>@link</b> #L_info} event which uses the 'INFO'
</span>   927    <span class="xdoc">     *  diags category. They do not allow you to specify an event priority.
</span>   928    <span class="xdoc">     *
</span>   929    <span class="xdoc">     *  Log_info prepends the filename and line number of the call site to the
</span>   930    <span class="xdoc">     *  message.
</span>   931    <span class="xdoc">     *
</span>   932    <span class="xdoc">     *  <b>@param(fmt)</b>     reference to a constant event string / fmt string
</span>   933    <span class="xdoc">     *  <b>@param(a1)</b>      value for an additional parameter (e.g. an event code)
</span>   934    <span class="xdoc">     *  <b>@param(a2)</b>      value for an additional parameter
</span>   935    <span class="xdoc">     *  <b>@param(a3)</b>      value for an additional parameter
</span>   936    <span class="xdoc">     *  <b>@param(a4)</b>      value for an additional parameter
</span>   937    <span class="xdoc">     *  <b>@param(a5)</b>      value for an additional parameter
</span>   938    <span class="xdoc">     *
</span>   939    <span class="xdoc">     *  <b>@a(Examples)</b>
</span>   940    <span class="xdoc">     *  The following example demonstrates a typical usage.
</span>   941    <span class="xdoc">     *  <b>@p(code)</b>
</span>   942    <span class="xdoc">     *  Int load;
</span>   943    <span class="xdoc">     *
</span>   944    <span class="xdoc">     *  Log_info1("Current load: %d", load);
</span>   945    <span class="xdoc">     *  <b>@p</b>
</span>   946    <span class="xdoc">     *  The above event is formatted as, for example:
</span>   947    <span class="xdoc">     *  <b>@p(code)</b>
</span>   948    <span class="xdoc">     *  "MyCode.c", line 15: Current load: 25
</span>   949    <span class="xdoc">     *  <b>@p</b>
</span>   950    <span class="xdoc">     */</span>
   951        @Macro Void info5(String fmt, IArg a1, IArg a2, IArg a3, IArg a4, IArg a5);
   952    
   953         <span class="xdoc">/*!
</span>   954    <span class="xdoc">     *  ======== put0 ========
</span>   955    <span class="xdoc">     *  Unconditionally put the specified Log event with 0 arguments
</span>   956    <span class="xdoc">     *
</span>   957    <span class="xdoc">     *  <b>@see</b> #put4
</span>   958    <span class="xdoc">     */</span>
   959        @Macro Void put0(Log.Event evt, Types.ModuleId mid);
   960    
   961        <span class="xdoc">/*!
</span>   962    <span class="xdoc">     *  ======== put1 ========
</span>   963    <span class="xdoc">     *  Unconditionally put the specified Log event and 1 argument
</span>   964    <span class="xdoc">     *
</span>   965    <span class="xdoc">     *  <b>@see</b> #put4
</span>   966    <span class="xdoc">     */</span>
   967        @Macro Void put1(Log.Event evt, Types.ModuleId mid, IArg a1);
   968    
   969        <span class="xdoc">/*!
</span>   970    <span class="xdoc">     *  ======== put2 ========
</span>   971    <span class="xdoc">     *  Unconditionally put the specified Log event and 2 arguments
</span>   972    <span class="xdoc">     *
</span>   973    <span class="xdoc">     *  <b>@see</b> #put4
</span>   974    <span class="xdoc">     */</span>
   975         @Macro Void put2(Log.Event evt, Types.ModuleId mid, IArg a1, IArg a2);
   976    
   977        <span class="xdoc">/*!
</span>   978    <span class="xdoc">     *  ======== put4 ========
</span>   979    <span class="xdoc">     *  Unconditionally put the specified Log event
</span>   980    <span class="xdoc">     *
</span>   981    <span class="xdoc">     *  This method unconditionally puts the specified `{<b>@link</b> Event}`
</span>   982    <span class="xdoc">     *  `evt` into the log. The `{<b>@link</b> Types#ModuleId}` `mid` should be the
</span>   983    <span class="xdoc">     *  module ID of the module which is putting the event.
</span>   984    <span class="xdoc">     *
</span>   985    <span class="xdoc">     *  <b>@param(evt)</b>     the Log event to put into the log
</span>   986    <span class="xdoc">     *  <b>@param(mid)</b>     module ID of the module putting the event
</span>   987    <span class="xdoc">     *  <b>@param(a1)</b>      value for first format conversion character
</span>   988    <span class="xdoc">     *  <b>@param(a2)</b>      value for second format conversion character
</span>   989    <span class="xdoc">     *  <b>@param(a3)</b>      value for third format conversion character
</span>   990    <span class="xdoc">     *  <b>@param(a4)</b>      value for fourth format conversion character
</span>   991    <span class="xdoc">     *
</span>   992    <span class="xdoc">     *  <b>@see</b> #put8
</span>   993    <span class="xdoc">     */</span>
   994        @Macro Void put4(Log.Event evt, Types.ModuleId mid, IArg a1, IArg a2,
   995                         IArg a3, IArg a4);
   996    
   997        <span class="xdoc">/*!
</span>   998    <span class="xdoc">     *  ======== put8 ========
</span>   999    <span class="xdoc">     *  Unconditionally put the specified Log event and 8 arguments
</span>  1000    <span class="xdoc">     *
</span>  1001    <span class="xdoc">     *  <b>@see</b> #put4
</span>  1002    <span class="xdoc">     */</span>
  1003        @Macro Void put8(Log.Event evt, Types.ModuleId mid, IArg a1, IArg a2,
  1004                         IArg a3, IArg a4, IArg a5, IArg a6, IArg a7, IArg a8);
  1005    
  1006        <span class="xdoc">/*!
</span>  1007    <span class="xdoc">     *  ======== write0 ========
</span>  1008    <span class="xdoc">     *  Generate a `Log` event with 0 arguments
</span>  1009    <span class="xdoc">     *
</span>  1010    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1011    <span class="xdoc">     */</span>
  1012        @Macro Void write0(Event evt);
  1013    
  1014        <span class="xdoc">/*!
</span>  1015    <span class="xdoc">     *  ======== write1 ========
</span>  1016    <span class="xdoc">     *  Generate a `Log` event with 1 argument
</span>  1017    <span class="xdoc">     *
</span>  1018    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1019    <span class="xdoc">     */</span>
  1020        @Macro Void write1(Event evt, IArg a1);
  1021    
  1022        <span class="xdoc">/*!
</span>  1023    <span class="xdoc">     *  ======== write2 ========
</span>  1024    <span class="xdoc">     *  Generate a `Log` event with 2 arguments
</span>  1025    <span class="xdoc">     *
</span>  1026    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1027    <span class="xdoc">     */</span>
  1028        @Macro Void write2(Event evt, IArg a1, IArg a2);
  1029    
  1030        <span class="xdoc">/*!
</span>  1031    <span class="xdoc">     *  ======== write3 ========
</span>  1032    <span class="xdoc">     *  Generate a `Log` event with 3 arguments
</span>  1033    <span class="xdoc">     *
</span>  1034    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1035    <span class="xdoc">     */</span>
  1036        @Macro Void write3(Event evt, IArg a1, IArg a2, IArg a3);
  1037    
  1038        <span class="xdoc">/*!
</span>  1039    <span class="xdoc">     *  ======== write4 ========
</span>  1040    <span class="xdoc">     *  Generate a `Log` event with 4 arguments
</span>  1041    <span class="xdoc">     *
</span>  1042    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1043    <span class="xdoc">     */</span>
  1044        @Macro Void write4(Event evt, IArg a1, IArg a2, IArg a3, IArg a4);
  1045    
  1046        <span class="xdoc">/*!
</span>  1047    <span class="xdoc">     *  ======== write5 ========
</span>  1048    <span class="xdoc">     *  Generate a `Log` event with 5 arguments
</span>  1049    <span class="xdoc">     *
</span>  1050    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1051    <span class="xdoc">     */</span>
  1052        @Macro Void write5(Event evt, IArg a1, IArg a2, IArg a3, IArg a4, IArg a5);
  1053    
  1054        <span class="xdoc">/*!
</span>  1055    <span class="xdoc">     *  ======== write6 ========
</span>  1056    <span class="xdoc">     *  Generate a `Log` event with 6 arguments
</span>  1057    <span class="xdoc">     *
</span>  1058    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1059    <span class="xdoc">     */</span>
  1060        @Macro Void write6(Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
  1061                            IArg a5, IArg a6);
  1062    
  1063        <span class="xdoc">/*!
</span>  1064    <span class="xdoc">     *  ======== write7 ========
</span>  1065    <span class="xdoc">     *  Generate a `Log` event with 7 arguments
</span>  1066    <span class="xdoc">     *
</span>  1067    <span class="xdoc">     *  <b>@see</b> #write8
</span>  1068    <span class="xdoc">     */</span>
  1069        @Macro Void write7(Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
  1070                            IArg a5, IArg a6, IArg a7);
  1071    
  1072        <span class="xdoc">/*!
</span>  1073    <span class="xdoc">     *  ======== write8 ========
</span>  1074    <span class="xdoc">     *  Generate a `Log` event with 8 arguments
</span>  1075    <span class="xdoc">     *
</span>  1076    <span class="xdoc">     *  If the mask in the specified `Log` event has any bit set which is
</span>  1077    <span class="xdoc">     *  also set in the current module's diagnostics mask, then this call to
</span>  1078    <span class="xdoc">     *  write will "raise" the given `Log` event.
</span>  1079    <span class="xdoc">     *
</span>  1080    <span class="xdoc">     *  <b>@param(evt)</b>     the `Log` event to write
</span>  1081    <span class="xdoc">     *  <b>@param(a1)</b>      value for first format conversion character
</span>  1082    <span class="xdoc">     *  <b>@param(a2)</b>      value for second format conversion character
</span>  1083    <span class="xdoc">     *  <b>@param(a3)</b>      value for third format conversion character
</span>  1084    <span class="xdoc">     *  <b>@param(a4)</b>      value for fourth format conversion character
</span>  1085    <span class="xdoc">     *  <b>@param(a5)</b>      value for fifth format conversion character
</span>  1086    <span class="xdoc">     *  <b>@param(a6)</b>      value for sixth format conversion character
</span>  1087    <span class="xdoc">     *  <b>@param(a7)</b>      value for seventh format conversion character
</span>  1088    <span class="xdoc">     *  <b>@param(a8)</b>      value for eighth format conversion character
</span>  1089    <span class="xdoc">     */</span>
  1090        @Macro Void write8(Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
  1091                            IArg a5, IArg a6, IArg a7, IArg a8);
  1092    
  1093        <span class="xdoc">/*!
</span>  1094    <span class="xdoc">     *  ======== doPrint ========
</span>  1095    <span class="xdoc">     *  Render an event as text via `{<b>@link</b> System#printf System_printf}`
</span>  1096    <span class="xdoc">     *
</span>  1097    <span class="xdoc">     *  This method is not gated and may make more than one call to
</span>  1098    <span class="xdoc">     *  `System_printf`.  This utility method is typically used within the
</span>  1099    <span class="xdoc">     *  implementation of a logger which initializes
</span>  1100    <span class="xdoc">     *  `{<b>@link</b> #EventRec Log_EventRec}` structures based on `Log` events
</span>  1101    <span class="xdoc">     *  produced by the application.
</span>  1102    <span class="xdoc">     *
</span>  1103    <span class="xdoc">     *  <b>@param(evRec)</b>   a non`NULL` pointer to an initialized `Log_EventRec`
</span>  1104    <span class="xdoc">     *                  structure to be formated via
</span>  1105    <span class="xdoc">     *                  `{<b>@link</b> System#printf System_printf}`.
</span>  1106    <span class="xdoc">     */</span>
  1107        Void doPrint(EventRec *evRec);
  1108    
  1109        <span class="xdoc">/*!
</span>  1110    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1111    <span class="xdoc">     *  ======== lookupEventMessage ========
</span>  1112    <span class="xdoc">     *  Returns the format string for the event with the given id.
</span>  1113    <span class="xdoc">     */</span>
  1114        <span class=key>function</span> lookupEventMessage(eventId);
  1115    
  1116        <span class="xdoc">/*!
</span>  1117    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1118    <span class="xdoc">     *  ======== getTargetArgSize ========
</span>  1119    <span class="xdoc">     *  Returns the target size of a record argument in bytes (not MAUs).
</span>  1120    <span class="xdoc">     */</span>
  1121        <span class=key>function</span> getTargetArgSize();
  1122    
  1123        <span class="xdoc">/*!
</span>  1124    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1125    <span class="xdoc">     *  ======== lookupEventName ========
</span>  1126    <span class="xdoc">     */</span>
  1127        <span class=key>function</span> lookupEventName(eventId);
  1128    
  1129        <span class="xdoc">/*!
</span>  1130    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1131    <span class="xdoc">     *  ======== lookupModuleName ========
</span>  1132    <span class="xdoc">     */</span>
  1133        <span class=key>function</span> lookupModuleName(modId);
  1134    
  1135        <span class="xdoc">/*!
</span>  1136    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1137    <span class="xdoc">     *  ======== getTargetEventRecSize ========
</span>  1138    <span class="xdoc">     *  Returns the record size in bytes (not MAUs).
</span>  1139    <span class="xdoc">     */</span>
  1140        <span class=key>function</span> getTargetEventRecSize();
  1141    
  1142    <span class=key>internal</span>:
  1143    
  1144        <span class="comment">/*
</span>  1145    <span class="comment">     *  ======== idToInfo ========
</span>  1146    <span class="comment">     *  Map event ID strings into a string of the form &lt;eventName&gt;::&lt;eventMsg&gt;
</span>  1147    <span class="comment">     */</span>
  1148        <span class=key>metaonly</span> <span class=key>config</span> String idToInfo[string] = [];
  1149    
  1150    }
  1151    <span class="comment">/*
</span>  1152    <span class="comment"> *  @(#) xdc.runtime; 2, 1, 0,371; 2-10-2012 10:18:55; /db/ztree/library/trees/xdc/xdc-y21x/src/packages/
</span>  1153    <span class="comment"> */</span>
  1154    
</pre>
</body></html>
