<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sdo.ipc.MessageQ</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* 
</span>     2    <span class="comment"> * Copyright (c) 2012, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> * */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== MessageQ.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> */</span>
    36    
    37    <span class=key>package</span> ti.sdo.ipc;
    38    
    39    import xdc.runtime.IHeap;
    40    import xdc.runtime.Assert;
    41    import xdc.runtime.Error;
    42    import xdc.runtime.Diags;
    43    import xdc.runtime.Log;
    44    import xdc.runtime.IGateProvider;
    45    import xdc.runtime.knl.ISync;
    46    
    47    import ti.sysbios.syncs.SyncSem;
    48    
    49    import ti.sdo.ipc.interfaces.IMessageQTransport;
    50    import ti.sdo.utils.NameServer;
    51    import ti.sdo.utils.List;
    52    
    53    import xdc.rov.ViewInfo;
    54    
    55    <span class="xdoc">/*!
</span>    56    <span class="xdoc"> *  ======== MessageQ ======== 
</span>    57    <span class="xdoc"> *  Message-passing with queuing
</span>    58    <span class="xdoc"> *
</span>    59    <span class="xdoc"> *  The MessageQ module supports the structured sending and receiving of 
</span>    60    <span class="xdoc"> *  variable length messages. This module can be used for homogeneous
</span>    61    <span class="xdoc"> *  (DSP to DSP)  or heterogeneous (Arm to DSP) multi-processor messaging. 
</span>    62    <span class="xdoc"> * 
</span>    63    <span class="xdoc"> *  MessageQ provides more sophisticated messaging than other modules. It is
</span>    64    <span class="xdoc"> *  typically used for complex situations such as multi-processor messaging. 
</span>    65    <span class="xdoc"> * 
</span>    66    <span class="xdoc"> *  The following are key features of the MessageQ module:
</span>    67    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    68    <span class="xdoc"> *  -Writers and readers can be relocated to another processor with no
</span>    69    <span class="xdoc"> *   runtime code changes.
</span>    70    <span class="xdoc"> *  -Timeouts are allowed when receiving messages.
</span>    71    <span class="xdoc"> *  -Readers can determine the writer and reply back.
</span>    72    <span class="xdoc"> *  -Receiving a message is deterministic when the timeout is zero.
</span>    73    <span class="xdoc"> *  -Messages can reside on any message queue.
</span>    74    <span class="xdoc"> *  -Supports zero-copy transfers.
</span>    75    <span class="xdoc"> *  -Can send and receive from any type of thread.
</span>    76    <span class="xdoc"> *  -Notification mechanism is specified by application.
</span>    77    <span class="xdoc"> *  -Allows QoS (quality of service) on message buffer pools. For example,
</span>    78    <span class="xdoc"> *   using specific buffer pools for specific message queues.
</span>    79    <span class="xdoc"> *  <b>@p</b>
</span>    80    <span class="xdoc"> *
</span>    81    <span class="xdoc"> *  Messages are sent and received by being placed on and removed from a
</span>    82    <span class="xdoc"> *  message queue. A reader is a thread that gets (reads) messages from a
</span>    83    <span class="xdoc"> *  message queue. A writer is a thread that puts (writes) a message to a
</span>    84    <span class="xdoc"> *  message queue. Each message queue has one reader and can have many writers.
</span>    85    <span class="xdoc"> *  A thread may read from or write to multiple message queues.
</span>    86    <span class="xdoc"> *
</span>    87    <span class="xdoc"> *  Conceptually, the reader thread owns a message queue. The reader thread
</span>    88    <span class="xdoc"> *  creates a message queue. The writer threads open a created message queue
</span>    89    <span class="xdoc"> *  to get access to them.
</span>    90    <span class="xdoc"> *
</span>    91    <span class="xdoc"> *  Message queues are identified by a system-wide unique name. Internally, 
</span>    92    <span class="xdoc"> *  MessageQ uses the {<b>@link</b> ti.sdo.utils.NameServer} module for managing 
</span>    93    <span class="xdoc"> *  these names. The names are used for opening a message queue.
</span>    94    <span class="xdoc"> * 
</span>    95    <span class="xdoc"> *  Messages must be allocated from the MessageQ module. Once a message is
</span>    96    <span class="xdoc"> *  allocated, it can be sent to any message queue. Once a message is sent, the
</span>    97    <span class="xdoc"> *  writer loses ownership of the message and should not attempt to modify the
</span>    98    <span class="xdoc"> *  message. Once the reader receives the message, it owns the message. It
</span>    99    <span class="xdoc"> *  may either free the message or re-use the message.
</span>   100    <span class="xdoc"> *
</span>   101    <span class="xdoc"> *  Messages in a message queue can be of variable length. The only
</span>   102    <span class="xdoc"> *  requirement is that the first field in the definition of a message must be a
</span>   103    <span class="xdoc"> *  {<b>@link</b> #MsgHeader} structure. For example:
</span>   104    <span class="xdoc"> *  <b>@p(code)</b>
</span>   105    <span class="xdoc"> *  typedef struct MyMsg {
</span>   106    <span class="xdoc"> *      MessageQ_MsgHeader header;
</span>   107    <span class="xdoc"> *      ...
</span>   108    <span class="xdoc"> *  } MyMsg;
</span>   109    <span class="xdoc"> *  <b>@p</b>
</span>   110    <span class="xdoc"> *
</span>   111    <span class="xdoc"> *  The MessageQ API uses the MessageQ_MsgHeader internally. Your application
</span>   112    <span class="xdoc"> *  should not modify or directly access the fields in the MessageQ_MsgHeader.
</span>   113    <span class="xdoc"> *
</span>   114    <span class="xdoc"> *  All messages sent via the MessageQ module must be allocated from a 
</span>   115    <span class="xdoc"> *  {<b>@link</b> xdc.runtime.IHeap} implementation. The heap can also be used for
</span>   116    <span class="xdoc"> *  other memory allocation not related to MessageQ.
</span>   117    <span class="xdoc"> *
</span>   118    <span class="xdoc"> *  An application can use multiple heaps. The purpose of having multiple
</span>   119    <span class="xdoc"> *  heaps is to allow an application to regulate its message usage. For
</span>   120    <span class="xdoc"> *  example, an application can allocate critical messages from one heap of fast
</span>   121    <span class="xdoc"> *  on-chip memory and non-critical messages from another heap of slower
</span>   122    <span class="xdoc"> *  external memory.
</span>   123    <span class="xdoc"> *
</span>   124    <span class="xdoc"> *  The {<b>@link</b> #registerHeap} and {<b>@link</b> #registerHeapMeta} are APIs used to
</span>   125    <span class="xdoc"> *  assign a MessageQ heapId to a heap. When allocating a message, the heapId
</span>   126    <span class="xdoc"> *  is used, not the heap handle. This heapId is actually placed into the 
</span>   127    <span class="xdoc"> *  message (part of the {<b>@link</b> #MsgHeader}). Care must be taken when assigning
</span>   128    <span class="xdoc"> *  heapIds. Refer to the {<b>@link</b> #registerHeap} and {<b>@link</b> #registerHeapMeta}
</span>   129    <span class="xdoc"> *  descriptions for more details.
</span>   130    <span class="xdoc"> *
</span>   131    <span class="xdoc"> *  MessageQ also supports the usage of messages that are not allocated via the
</span>   132    <span class="xdoc"> *  {<b>@link</b> #alloc} function. Please refer to the {<b>@link</b> #staticMsgInit}
</span>   133    <span class="xdoc"> *  function description for more details.
</span>   134    <span class="xdoc"> *
</span>   135    <span class="xdoc"> *  MessageQ supports reads/writes of different thread models. This is
</span>   136    <span class="xdoc"> *  accomplished by having the creator of the message queue specify a 
</span>   137    <span class="xdoc"> *  {<b>@link</b> xdc.runtime.knl.ISync#Object} via the {<b>@link</b> #synchronizer}
</span>   138    <span class="xdoc"> *  configuration parameter. The {<b>@link</b> xdc.runtime.knl.ISync#signal} 
</span>   139    <span class="xdoc"> *  portion of the ISync instance is called whenever the {<b>@link</b> #put}
</span>   140    <span class="xdoc"> *  is called. The {<b>@link</b> xdc.runtime.knl.ISync#wait} portion is 
</span>   141    <span class="xdoc"> *  called in the {<b>@link</b> #get} if and only if there are no messages.
</span>   142    <span class="xdoc"> *
</span>   143    <span class="xdoc"> *  Since ISyncs are binary, the reader must drain the message queue of all
</span>   144    <span class="xdoc"> *  messages before waiting for another signal. For example, if the reader 
</span>   145    <span class="xdoc"> *  was a SYSBIOS Swi, the {<b>@link</b> xdc.runtime.knl.ISync} instance 
</span>   146    <span class="xdoc"> *  could be a SyncSwi. If a {<b>@link</b> #put} was called, the Swi_post() would 
</span>   147    <span class="xdoc"> *  be called. The Swi would run and it must call {<b>@link</b> #get} until no 
</span>   148    <span class="xdoc"> *  messages are returned.
</span>   149    <span class="xdoc"> * 
</span>   150    <span class="xdoc"> *  In a multiple processor system, MessageQ communicates to other
</span>   151    <span class="xdoc"> *  processors via {<b>@link</b> ti.sdo.ipc.interfaces.IMessageQTransport} instances.  
</span>   152    <span class="xdoc"> *  MessageQ supports a high priority and a normal priority transport between 
</span>   153    <span class="xdoc"> *  any two processors. The IMessageQTransport instances are created via the
</span>   154    <span class="xdoc"> *  {<b>@link</b> #SetupTransportProxy}. The instances are responsible for
</span>   155    <span class="xdoc"> *  registering themselves with MessageQ. This is accomplished via the
</span>   156    <span class="xdoc"> * {<b>@link</b> #registerTransport} function.
</span>   157    <span class="xdoc"> */</span>
   158    
   159    @ModuleStartup 
   160    @InstanceInitError
   161    @InstanceFinalize
   162    
   163    <span class=key>module</span> MessageQ
   164    {
   165        <span class="xdoc">/*!
</span>   166    <span class="xdoc">     *  ======== QueuesView ========
</span>   167    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   168    <span class="xdoc">     */</span>
   169        <span class=key>metaonly</span> <span class=key>struct</span> QueuesView {
   170            String  name;
   171            UInt    queueId;
   172        }
   173        
   174        <span class="xdoc">/*!
</span>   175    <span class="xdoc">     *  ======== MessagesView ========
</span>   176    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   177    <span class="xdoc">     */</span>
   178        <span class=key>metaonly</span> <span class=key>struct</span> MessagesView {
   179            Int          seqNum;
   180            Int          msgSize;
   181            String       priority;
   182            String       srcProc;        
   183            String       replyProc;
   184            String       replyId;
   185            Int          msgId;          
   186            String       heap;
   187            Bool         traceEnabled;
   188            Int          version;
   189        }
   190    
   191        <span class="xdoc">/*!
</span>   192    <span class="xdoc">     *  ======== ModuleView ========
</span>   193    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   194    <span class="xdoc">     */</span>
   195        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {        
   196            String               heaps[];        
   197            String               gate;
   198            UInt16               nextSeqNum;
   199        }
   200        
   201        <span class="xdoc">/*!
</span>   202    <span class="xdoc">     *  ======== rovViewInfo ========
</span>   203    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   204    <span class="xdoc">     */</span>
   205        @Facet
   206        <span class=key>metaonly</span> <span class=key>config</span> xdc.rov.ViewInfo.Instance rovViewInfo = 
   207            xdc.rov.ViewInfo.create({
   208                viewMap: [
   209                    [<span class="string">'Queues'</span>,
   210                        {
   211                            type: xdc.rov.ViewInfo.INSTANCE,
   212                            viewInitFxn: <span class="string">'viewInitQueues'</span>,
   213                            structName: <span class="string">'QueuesView'</span>
   214                        }
   215                    ],
   216                    [<span class="string">'Messages'</span>, 
   217                        {
   218                            type: xdc.rov.ViewInfo.INSTANCE_DATA,
   219                            viewInitFxn: <span class="string">'viewInitMessages'</span>,
   220                            structName: <span class="string">'MessagesView'</span>
   221                        }
   222                    ],
   223                    [<span class="string">'Module'</span>, 
   224                        {
   225                            type: xdc.rov.ViewInfo.MODULE,
   226                            viewInitFxn: <span class="string">'viewInitModule'</span>,
   227                            structName: <span class="string">'ModuleView'</span>
   228                        }
   229                    ]
   230                ]
   231            });
   232        
   233        <span class="xdoc">/*!
</span>   234    <span class="xdoc">     *  ======== LM_setTrace ========
</span>   235    <span class="xdoc">     *  Logged when setting the trace flag on a message
</span>   236    <span class="xdoc">     *
</span>   237    <span class="xdoc">     *  This is logged when tracing on a message is set via
</span>   238    <span class="xdoc">     *  {<b>@link</b> #setMsgTrace}.
</span>   239    <span class="xdoc">     */</span>
   240        <span class=key>config</span> Log.Event LM_setTrace = {
   241            mask: Diags.USER1,
   242            msg: <span class="string">"LM_setTrace: Message 0x%x (seqNum = %d, srcProc = %d) traceFlag = %d"</span>
   243        };
   244        
   245        <span class="xdoc">/*!
</span>   246    <span class="xdoc">     *  ======== LM_alloc ========
</span>   247    <span class="xdoc">     *  Logged when allocating a message
</span>   248    <span class="xdoc">     *
</span>   249    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all message allocations
</span>   250    <span class="xdoc">     *  are logged.
</span>   251    <span class="xdoc">     */</span>
   252        <span class=key>config</span> Log.Event LM_alloc = {
   253            mask: Diags.USER1,
   254            msg: <span class="string">"LM_alloc: Message 0x%x (seqNum = %d, srcProc = %d) was allocated"</span>
   255        };
   256        
   257        <span class="xdoc">/*!
</span>   258    <span class="xdoc">     *  ======== LM_staticMsgInit ========
</span>   259    <span class="xdoc">     *  Logged when statically initializing a message
</span>   260    <span class="xdoc">     *
</span>   261    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all messages that
</span>   262    <span class="xdoc">     *  are statically initialized via {<b>@link</b> #staticMsgInit} are logged.
</span>   263    <span class="xdoc">     */</span>
   264        <span class=key>config</span> Log.Event LM_staticMsgInit = {
   265            mask: Diags.USER1,
   266            msg: <span class="string">"LM_staticMsgInit: Message 0x%x (seqNum = %d, srcProc = %d) was set in MessageQ_staticMsgInit"</span>
   267        };
   268        
   269        <span class="xdoc">/*!
</span>   270    <span class="xdoc">     *  ======== LM_free ========
</span>   271    <span class="xdoc">     *  Logged when freeing a message
</span>   272    <span class="xdoc">     *
</span>   273    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all freeing of messages
</span>   274    <span class="xdoc">     *  are logged. If an individual message's tracing was enabled 
</span>   275    <span class="xdoc">     *  via {<b>@link</b> #setMsgTrace}, the MessageQ_free is also logged.
</span>   276    <span class="xdoc">     */</span>
   277        <span class=key>config</span> Log.Event LM_free = {
   278            mask: Diags.USER1,
   279            msg: <span class="string">"LM_free: Message 0x%x (seqNum = %d, srcProc = %d) was freed"</span>
   280        };
   281        
   282        <span class="xdoc">/*!
</span>   283    <span class="xdoc">     *  ======== LM_putLocal ========
</span>   284    <span class="xdoc">     *  Logged when a message is placed onto a local queue
</span>   285    <span class="xdoc">     *
</span>   286    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all putting of messages
</span>   287    <span class="xdoc">     *  are logged. If an individual message's tracing was enabled 
</span>   288    <span class="xdoc">     *  via {<b>@link</b> #setMsgTrace}, the MessageQ_put is also logged.
</span>   289    <span class="xdoc">     */</span>
   290        <span class=key>config</span> Log.Event LM_putLocal = {
   291            mask: Diags.USER1,
   292            msg: <span class="string">"LM_putLocal: Message 0x%x (seqNum = %d, srcProc = %d) was placed onto queue 0x%x"</span>
   293        };
   294        
   295        <span class="xdoc">/*!
</span>   296    <span class="xdoc">     *  ======== LM_putRemote ========
</span>   297    <span class="xdoc">     *  Logged when a message is given to a transport
</span>   298    <span class="xdoc">     *
</span>   299    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all putting of messages
</span>   300    <span class="xdoc">     *  to a transport are logged. If an individual message's tracing
</span>   301    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the MessageQ_put is 
</span>   302    <span class="xdoc">     *  also logged.
</span>   303    <span class="xdoc">     */</span>
   304        <span class=key>config</span> Log.Event LM_putRemote = {
   305            mask: Diags.USER1,
   306            msg: <span class="string">"LM_putRemote: Message 0x%x (seqNum = %d, srcProc = %d) was given to processor %d transport"</span>
   307        };
   308        
   309        <span class="xdoc">/*!
</span>   310    <span class="xdoc">     *  ======== LM_rcvByTransport ========
</span>   311    <span class="xdoc">     *  Logged when a transport receives an incoming message
</span>   312    <span class="xdoc">     *
</span>   313    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all incoming messages
</span>   314    <span class="xdoc">     *  are logged. If an individual message's tracing
</span>   315    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the receiving of a message is 
</span>   316    <span class="xdoc">     *  also logged.
</span>   317    <span class="xdoc">     */</span>
   318        <span class=key>config</span> Log.Event LM_rcvByTransport = {
   319            mask: Diags.USER1,
   320            msg: <span class="string">"LM_rcvByTransport: Message 0x%x (seqNum = %d, srcProc = %d) was received"</span>
   321        };
   322        
   323        <span class="xdoc">/*!
</span>   324    <span class="xdoc">     *  ======== LM_get ========
</span>   325    <span class="xdoc">     *  Logged when a message is received off the queue
</span>   326    <span class="xdoc">     *
</span>   327    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all getting of messages
</span>   328    <span class="xdoc">     *  are logged. If an individual message's tracing
</span>   329    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the MessageQ_get is 
</span>   330    <span class="xdoc">     *  also logged.
</span>   331    <span class="xdoc">     */</span>
   332        <span class=key>config</span> Log.Event LM_get = {
   333            mask: Diags.USER1,
   334            msg: <span class="string">"LM_get: Message 0x%x (seqNum = %d, srcProc = %d) was received by queue 0x%x"</span>
   335        };
   336        
   337        <span class="xdoc">/*! MessageQ ID */</span>
   338        <span class=key>typedef</span> UInt32 QueueId;
   339        
   340        <span class="xdoc">/*!
</span>   341    <span class="xdoc">     *  ======== SetupTransportProxy ========
</span>   342    <span class="xdoc">     *  MessageQ transport setup proxy
</span>   343    <span class="xdoc">     */</span>
   344        <span class=key>proxy</span> SetupTransportProxy <span class=key>inherits</span> ti.sdo.ipc.interfaces.ITransportSetup;
   345        
   346        <span class="xdoc">/*!
</span>   347    <span class="xdoc">     *  Message priority values. These must match the values defined in
</span>   348    <span class="xdoc">     *  ti/ipc/MessageQ.h but are needed here for ROV.
</span>   349    <span class="xdoc">     */</span>
   350        <span class=key>const</span> UInt NORMALPRI   = 0;
   351        <span class=key>const</span> UInt HIGHPRI     = 1;
   352        <span class=key>const</span> UInt RESERVEDPRI = 2;
   353        <span class=key>const</span> UInt URGENTPRI   = 3;
   354        
   355        <span class="xdoc">/*!
</span>   356    <span class="xdoc">     *  Assert raised when calling API with wrong handle
</span>   357    <span class="xdoc">     *
</span>   358    <span class="xdoc">     *  Some APIs can only be called with an opened handle (e.g. 
</span>   359    <span class="xdoc">     *  {<b>@link</b> #close}. Some can only be called with a created handle
</span>   360    <span class="xdoc">     *  (e.g. {<b>@link</b> #get}).
</span>   361    <span class="xdoc">     */</span>
   362        <span class=key>config</span> Assert.Id A_invalidContext  = {
   363            msg: <span class="string">"A_invalidContext: Cannot call with an open/create handle"</span>
   364        };
   365                
   366        <span class="xdoc">/*!
</span>   367    <span class="xdoc">     *  Assert raised when attempting to free a static message
</span>   368    <span class="xdoc">     */</span>
   369        <span class=key>config</span> Assert.Id A_cannotFreeStaticMsg  = {
   370            msg: <span class="string">"A_cannotFreeStaticMsg: Cannot call MessageQ_free with static msg"</span>
   371        };
   372        
   373        <span class="xdoc">/*!
</span>   374    <span class="xdoc">     *  Assert raised when an invalid message is supplied
</span>   375    <span class="xdoc">     */</span>
   376        <span class=key>config</span> Assert.Id A_invalidMsg  = {
   377            msg: <span class="string">"A_invalidMsg: Invalid message"</span>
   378        };
   379    
   380        <span class="xdoc">/*!
</span>   381    <span class="xdoc">     *  Assert raised when an invalid queueId is supplied
</span>   382    <span class="xdoc">     */</span>
   383        <span class=key>config</span> Assert.Id A_invalidQueueId  = {
   384            msg: <span class="string">"A_invalidQueueId: Invalid queueId is used"</span>
   385        };
   386    
   387        <span class="xdoc">/*!
</span>   388    <span class="xdoc">     *  Assert raised when using an invalid heapId
</span>   389    <span class="xdoc">     */</span>
   390        <span class=key>config</span> Assert.Id A_heapIdInvalid  = {
   391            msg: <span class="string">"A_heapIdInvalid: heapId is invalid"</span>
   392        };
   393        
   394        <span class="xdoc">/*!
</span>   395    <span class="xdoc">     *  Assert raised when using an invalid procId
</span>   396    <span class="xdoc">     */</span>
   397        <span class=key>config</span> Assert.Id A_procIdInvalid  = {
   398            msg: <span class="string">"A_procIdInvalid: procId is invalid"</span>
   399        };
   400        
   401        <span class="xdoc">/*!
</span>   402    <span class="xdoc">     *  Assert raised for an invalid MessageQ object 
</span>   403    <span class="xdoc">     */</span>
   404        <span class=key>config</span> Assert.Id A_invalidObj  = {
   405            msg: <span class="string">"A_invalidObj: an invalid obj is used"</span>
   406        };
   407    
   408        <span class="xdoc">/*!
</span>   409    <span class="xdoc">     *  Assert raised for an invalid parameter 
</span>   410    <span class="xdoc">     */</span>
   411        <span class=key>config</span> Assert.Id A_invalidParam  = {
   412            msg: <span class="string">"A_invalidParam: an invalid parameter was passed in"</span>
   413        };
   414    
   415        <span class="xdoc">/*!
</span>   416    <span class="xdoc">     *  Assert raised when attempting to send a message to a core
</span>   417    <span class="xdoc">     *  where a transport has not been registered.
</span>   418    <span class="xdoc">     */</span>
   419        <span class=key>config</span> Assert.Id A_unregisteredTransport  = {
   420            msg: <span class="string">"A_unregisteredTransport: transport is not registered"</span>
   421        };
   422        
   423        <span class="xdoc">/*!
</span>   424    <span class="xdoc">     *  Assert raised when attempting to unblock a remote MessageQ or one that
</span>   425    <span class="xdoc">     *  has been configured with a non-blocking synchronizer
</span>   426    <span class="xdoc">     */</span>
   427        <span class=key>config</span> Assert.Id A_invalidUnblock  = {
   428            msg: <span class="string">"A_invalidUnblock: Trying to unblock a remote MessageQ or a queue with non-blocking synchronizer"</span>
   429        };
   430        
   431        <span class="xdoc">/*!
</span>   432    <span class="xdoc">     *  Error raised if all the message queue objects are taken
</span>   433    <span class="xdoc">     */</span>
   434        <span class=key>config</span> Error.Id E_maxReached  = {
   435            msg: <span class="string">"E_maxReached: All objects in use. MessageQ.maxRuntimeEntries is %d"</span>
   436        };
   437        
   438        <span class="xdoc">/*!
</span>   439    <span class="xdoc">     *  Error raised when heapId has not been registered
</span>   440    <span class="xdoc">     */</span>
   441        <span class=key>config</span> Error.Id E_unregisterHeapId  = {
   442            msg: <span class="string">"E_unregisterHeapId: Heap id %d not registered"</span>
   443        };
   444    
   445        <span class="xdoc">/*!
</span>   446    <span class="xdoc">     *  Error raised in a create call when a name fails to be added
</span>   447    <span class="xdoc">     *  to the NameServer table.  This can be because the name already
</span>   448    <span class="xdoc">     *  exists, the table has reached its max length, or out of memory.
</span>   449    <span class="xdoc">     */</span>
   450        <span class=key>config</span> Error.Id E_nameFailed  = {
   451            msg: <span class="string">"E_nameFailed: '%s' name failed to be added to NameServer"</span>
   452        };
   453    
   454        <span class="xdoc">/*!
</span>   455    <span class="xdoc">     *  Trace setting
</span>   456    <span class="xdoc">     *
</span>   457    <span class="xdoc">     *  This flag allows the configuration of the default module trace 
</span>   458    <span class="xdoc">     *  settings.     
</span>   459    <span class="xdoc">     */</span>
   460        <span class=key>config</span> Bool traceFlag = <span class=key>false</span>;    
   461        
   462        <span class="xdoc">/*!
</span>   463    <span class="xdoc">     *  Number of heapIds in the system
</span>   464    <span class="xdoc">     *
</span>   465    <span class="xdoc">     *  This allows MessageQ to pre-allocate the heaps table.
</span>   466    <span class="xdoc">     *  The heaps table is used when registering heaps.
</span>   467    <span class="xdoc">     *
</span>   468    <span class="xdoc">     *  There is no default heap, so unless the system is only using
</span>   469    <span class="xdoc">     *  {<b>@link</b> #staticMsgInit}, the application must register a heap.
</span>   470    <span class="xdoc">     */</span>
   471        <span class=key>config</span> UInt16 numHeaps = 8;
   472        
   473        <span class="xdoc">/*! 
</span>   474    <span class="xdoc">     *  Maximum number of MessageQs that can be dynamically created
</span>   475    <span class="xdoc">     */</span>
   476        <span class=key>config</span> UInt maxRuntimeEntries = NameServer.ALLOWGROWTH;
   477        
   478        <span class="xdoc">/*! 
</span>   479    <span class="xdoc">     *  Gate used to make the name table thread safe
</span>   480    <span class="xdoc">     *
</span>   481    <span class="xdoc">     *  This gate is used when accessing the name table during 
</span>   482    <span class="xdoc">     *  a {<b>@link</b> #create}, {<b>@link</b> #delete}, and {<b>@link</b> #open}.
</span>   483    <span class="xdoc">     *
</span>   484    <span class="xdoc">     *  This gate is also used to protect MessageQ when growing
</span>   485    <span class="xdoc">     *  internal tables in the {<b>@link</b> #create}.
</span>   486    <span class="xdoc">     *
</span>   487    <span class="xdoc">     *  The table is in local memory, not shared memory. So a
</span>   488    <span class="xdoc">     *  single processor gate will work.
</span>   489    <span class="xdoc">     *
</span>   490    <span class="xdoc">     *  The default will be {<b>@link</b> xdc.runtime.knl.GateThread}
</span>   491    <span class="xdoc">     *  instance.
</span>   492    <span class="xdoc">     */</span>
   493        <span class=key>config</span> IGateProvider.Handle nameTableGate = <span class=key>null</span>;
   494        
   495        <span class="xdoc">/*! 
</span>   496    <span class="xdoc">     *  Maximum length for Message queue names
</span>   497    <span class="xdoc">     */</span>
   498        <span class=key>config</span> UInt maxNameLen = 32;
   499    
   500        <span class="xdoc">/*! 
</span>   501    <span class="xdoc">     *  Section name is used to place the names table
</span>   502    <span class="xdoc">     */</span>
   503        <span class=key>metaonly</span> <span class=key>config</span> String tableSection = <span class=key>null</span>;
   504        
   505        <span class="xdoc">/*!
</span>   506    <span class="xdoc">     *  ======== registerHeapMeta ========
</span>   507    <span class="xdoc">     *  Statically register a heap with MessageQ
</span>   508    <span class="xdoc">     *
</span>   509    <span class="xdoc">     *  Build error if heapId is in use.
</span>   510    <span class="xdoc">     *
</span>   511    <span class="xdoc">     *  <b>@param(heap)</b>        Heap to register
</span>   512    <span class="xdoc">     *  <b>@param(heapId)</b>      heapId associated with the heap
</span>   513    <span class="xdoc">     */</span>
   514        <span class=key>metaonly</span> Void registerHeapMeta(IHeap.Handle heap, UInt16 heapId);
   515         
   516         <span class="xdoc">/*!
</span>   517    <span class="xdoc">     *  ======== registerTransportMeta ========
</span>   518    <span class="xdoc">     *  Statically register a transport with MessageQ
</span>   519    <span class="xdoc">     *
</span>   520    <span class="xdoc">     *  Build error if remote processor already has a transport
</span>   521    <span class="xdoc">     *  registered.
</span>   522    <span class="xdoc">     *
</span>   523    <span class="xdoc">     *  <b>@param(transport)</b>   transport to register
</span>   524    <span class="xdoc">     *  <b>@param(procId)</b>      procId that transport communicaties with
</span>   525    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   526    <span class="xdoc">     */</span>
   527         <span class=key>metaonly</span> Void registerTransportMeta(IMessageQTransport.Handle transport, UInt16 procId, UInt priority);
   528         
   529        <span class="xdoc">/*!
</span>   530    <span class="xdoc">     *  ======== registerTransport ========
</span>   531    <span class="xdoc">     *  Register a transport with MessageQ
</span>   532    <span class="xdoc">     *
</span>   533    <span class="xdoc">     *  This API is called by the transport when it is created.
</span>   534    <span class="xdoc">     *
</span>   535    <span class="xdoc">     *  <b>@param(transport)</b>   transport to register
</span>   536    <span class="xdoc">     *  <b>@param(procId)</b>      MultiProc id that transport communicates with
</span>   537    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   538    <span class="xdoc">     *
</span>   539    <span class="xdoc">     *  <b>@b(returns)</b>         Whether the register was successful.
</span>   540    <span class="xdoc">     */</span>
   541        Bool registerTransport(IMessageQTransport.Handle transport, UInt16 procId,
   542            UInt priority);
   543    
   544        <span class="xdoc">/*!
</span>   545    <span class="xdoc">     *  ======== unregisterTransport ========
</span>   546    <span class="xdoc">     *  Unregister a transport with MessageQ
</span>   547    <span class="xdoc">     *
</span>   548    <span class="xdoc">     *  <b>@param(procId)</b>      unregister transport that communicates with
</span>   549    <span class="xdoc">     *                      this remote processor
</span>   550    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   551    <span class="xdoc">     */</span>
   552        Void unregisterTransport(UInt16 procId, UInt priority);
   553        
   554    <span class=key>instance</span>:
   555      
   556        <span class="xdoc">/*! 
</span>   557    <span class="xdoc">     *  ISync handle used to signal IO completion 
</span>   558    <span class="xdoc">     *
</span>   559    <span class="xdoc">     *  The ISync instance is used in the {<b>@link</b> #get} and {<b>@link</b> #put}.
</span>   560    <span class="xdoc">     *  The {<b>@link</b> xdc.runtime.knl.ISync#signal} is called as part
</span>   561    <span class="xdoc">     *  of the {<b>@link</b> #put} call.  The {<b>@link</b> xdc.runtime.knl.ISync#wait} is 
</span>   562    <span class="xdoc">     *  called in the {<b>@link</b> #get} if there are no messages present.
</span>   563    <span class="xdoc">     */</span>
   564        <span class=key>config</span> ISync.Handle synchronizer = <span class=key>null</span>;
   565        
   566        <span class="xdoc">/*! <b>@_nodoc</b>
</span>   567    <span class="xdoc">     *  ======== create ========
</span>   568    <span class="xdoc">     *  Create a message queue
</span>   569    <span class="xdoc">     *
</span>   570    <span class="xdoc">     *  <b>@param(name)</b>         Name of the message queue.
</span>   571    <span class="xdoc">     */</span>
   572        create(String name);   
   573        
   574    <span class=key>internal</span>:
   575        <span class="comment">/* 
</span>   576    <span class="comment">     *  The following describes the usage of the flag field     
</span>   577    <span class="comment">     *  ---------------------------------
</span>   578    <span class="comment">     *  |V V V|T|     reserved      |P P|
</span>   579    <span class="comment">     *  ---------------------------------
</span>   580    <span class="comment">     *   E D C B A 0 9 8 7 6 5 4 3 2 1 0
</span>   581    <span class="comment">     *     
</span>   582    <span class="comment">     *  V = version
</span>   583    <span class="comment">     *  P = priority
</span>   584    <span class="comment">     *  T = trace flag
</span>   585    <span class="comment">     */</span>
   586    
   587        <span class="xdoc">/*! Mask to extract version setting */</span>
   588        <span class=key>const</span> UInt VERSIONMASK = 0xE000;
   589        
   590        <span class="xdoc">/*! Version setting */</span>
   591        <span class=key>const</span> UInt HEADERVERSION = 0x2000;
   592        
   593        <span class="xdoc">/*! Mask to extract Trace setting */</span>
   594        <span class=key>const</span> UInt TRACEMASK = 0x1000;
   595        
   596        <span class="xdoc">/*! Shift for Trace setting */</span>
   597        <span class=key>const</span> UInt TRACESHIFT = 12;
   598           
   599        <span class="xdoc">/*!
</span>   600    <span class="xdoc">     *  Mask to extract priority setting.
</span>   601    <span class="xdoc">     *  This is needed here for ROV but must match
</span>   602    <span class="xdoc">     *  the value defined in ti/ipc/MessageQ.h
</span>   603    <span class="xdoc">     */</span>
   604        <span class=key>const</span> UInt PRIORITYMASK = 0x3;
   605        
   606        <span class="xdoc">/*! Mask to extract priority setting */</span>
   607        <span class=key>const</span> UInt TRANSPORTPRIORITYMASK = 0x1;
   608            
   609         <span class="xdoc">/*! return code for Instance_init */</span>
   610        <span class=key>const</span> Int PROXY_FAILURE = 1;
   611    
   612        <span class="comment">/* 
</span>   613    <span class="comment">     *  Used to denote a message that was initialized 
</span>   614    <span class="comment">     *  with the MessageQ_staticMsgInit function.
</span>   615    <span class="comment">     */</span>
   616        <span class=key>const</span> UInt16 STATICMSG = 0xFFFF;
   617    
   618        <span class="xdoc">/*! Required first field in every message */</span>
   619        @Opaque <span class=key>struct</span> MsgHeader {
   620            Bits32       reserved0;         <span class="comment">/* reserved for List.elem-&gt;next */</span>
   621            Bits32       reserved1;         <span class="comment">/* reserved for List.elem-&gt;prev */</span>
   622            Bits32       msgSize;           <span class="comment">/* message size                 */</span>
   623            Bits16       flags;             <span class="comment">/* bitmask of different flags   */</span>
   624            Bits16       msgId;             <span class="comment">/* message id                   */</span>
   625            Bits16       dstId;             <span class="comment">/* destination processor id     */</span>
   626            Bits16       dstProc;           <span class="comment">/* destination processor        */</span>
   627            Bits16       replyId;           <span class="comment">/* reply id                     */</span>
   628            Bits16       replyProc;         <span class="comment">/* reply processor              */</span>
   629            Bits16       srcProc;           <span class="comment">/* source processor             */</span>
   630            Bits16       heapId;            <span class="comment">/* heap id                      */</span>
   631            Bits16       seqNum;            <span class="comment">/* sequence number              */</span>
   632            Bits16       reserved;          <span class="comment">/* reserved                     */</span>
   633        };
   634        
   635        <span class=key>struct</span> HeapEntry {
   636            IHeap.Handle  heap;
   637            UInt16        heapId;
   638        };
   639        
   640        <span class=key>struct</span> TransportEntry {
   641            IMessageQTransport.Handle  transport;
   642            UInt16             procId;
   643        };
   644        
   645        <span class="xdoc">/*! 
</span>   646    <span class="xdoc">     *  ======== nameSrvPrms ========
</span>   647    <span class="xdoc">     *  This Params object is used for temporary storage of the
</span>   648    <span class="xdoc">     *  module wide parameters that are for setting the NameServer instance.
</span>   649    <span class="xdoc">     */</span>
   650        <span class=key>metaonly</span> <span class=key>config</span> NameServer.Params nameSrvPrms;
   651        
   652        <span class="xdoc">/*! 
</span>   653    <span class="xdoc">     *  Statically registered heaps
</span>   654    <span class="xdoc">     *
</span>   655    <span class="xdoc">     *  This configuration parameter allows the static registeration
</span>   656    <span class="xdoc">     *  of heaps. The index of the array corresponds to the heapId.     
</span>   657    <span class="xdoc">     */</span>
   658        <span class=key>metaonly</span> <span class=key>config</span> HeapEntry staticHeaps[];
   659        
   660        <span class="xdoc">/*! 
</span>   661    <span class="xdoc">     *  Statically registered transports
</span>   662    <span class="xdoc">     *
</span>   663    <span class="xdoc">     *  This configuration parameter allows the static registeration
</span>   664    <span class="xdoc">     *  of transports. The index of the array corresponds to the procId.     
</span>   665    <span class="xdoc">     */</span>
   666        <span class=key>metaonly</span> <span class=key>config</span> TransportEntry staticTransports[];
   667        
   668        <span class="xdoc">/*!
</span>   669    <span class="xdoc">     *  Allows for the number of dynamically created message queues to grow.
</span>   670    <span class="xdoc">     */</span>
   671        UInt16 grow(Object *obj, Error.Block *eb);
   672      
   673        <span class=key>struct</span> Instance_State {
   674            QueueId         queue;        <span class="comment">/* Unique id                     */</span>
   675            ISync.Handle    synchronizer; <span class="comment">/* completion synchronizer       */</span>
   676            List.Object     normalList;   <span class="comment">/* Embedded List objects         */</span>
   677            List.Object     highList;     <span class="comment">/* Embedded List objects         */</span>
   678            Ptr             nsKey;        <span class="comment">/* unique NameServer key         */</span>
   679            SyncSem.Handle  syncSemHandle;<span class="comment">/* for use in finalize           */</span>
   680            Bool            unblocked;    <span class="comment">/* Whether MessageQ is unblocked */</span>
   681        };
   682      
   683        <span class=key>struct</span> Module_State {        
   684            IMessageQTransport.Handle transports[][2];
   685            Handle               queues[];        
   686            IHeap.Handle         heaps[];        
   687            IGateProvider.Handle gate;
   688            UInt16               numQueues;
   689            UInt16               numHeaps;        
   690            NameServer.Handle    nameServer;
   691            Bool                 canFreeQueues;
   692            UInt16               seqNum;
   693        };
   694    } 
   695    <span class="comment">/*
</span>   696    <span class="comment"> *  @(#) ti.sdo.ipc; 1, 0, 0, 0,2; 2-11-2012 16:30:34; /db/vtree/library/trees/ipc/ipc-h27/src/ xlibrary
</span>   697    <span class="comment">
</span>   698    <span class="comment"> */</span>
   699    
</pre>
</body></html>
