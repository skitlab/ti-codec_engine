/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/*
 *  ======== Processor_noOS.c ========
 */

/* This define must precede inclusion of any xdc header files */
#define Registry_CURDESC ti_sdo_ce_ipc_processor_desc

/* Build library with MessageQ (Ipc) by default. */
#ifndef MESSAGEQ_ENABLED
#define MESSAGEQ_ENABLED 1
#endif

#include <xdc/std.h>
#include <xdc/runtime/Assert.h>
#include <xdc/runtime/Diags.h>
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Registry.h>

#include <xdc/runtime/Memory.h>

#include <stdio.h>  /* for sprintf() */

#include <ti/sdo/ce/global/CESettings.h>

#include <ti/sdo/ce/ipc/Comm.h>
#include <ti/sdo/ce/ipc/Processor.h>

#if MESSAGEQ_ENABLED

#include <ti/ipc/HeapBufMP.h>
#include <ti/ipc/MessageQ.h>
#include <ti/ipc/MultiProc.h>


/* Generated by .xdt file */
#define Processor_defaultSharedRegionId ti_sdo_ce_ipc_bios__Processor_defaultSharedRegionId
#define Processor_defaultHeapId ti_sdo_ce_ipc_bios__Processor_defaultHeapId
#define Processor_defaultNumMsgs ti_sdo_ce_ipc_bios__Processor_defaultNumMsgs
#define Processor_defaultMsgSize ti_sdo_ce_ipc_bios__Processor_defaultMsgSize
#define Processor_commDescs ti_sdo_ce_ipc_bios__Processor_commDescs
#define Processor_numCommDescs ti_sdo_ce_ipc_bios__Processor_numCommDescs

/* Generated by .xdt file */
extern Int16 Processor_defaultSharedRegionId;
extern Int16 Processor_defaultHeapId;
extern Int32 Processor_defaultNumMsgs;
extern Int32 Processor_defaultMsgSize;
extern Processor_CommDesc Processor_commDescs[];
extern UInt32 Processor_numCommDescs;

extern Int Comm_NUMMSGS;

#endif

/*
 *  ======== Processor_Obj ========
 */
typedef struct Processor_Obj {
#if MESSAGEQ_ENABLED
    HeapBufMP_Handle hHeap;
#endif
    UInt16           heapId;
} Processor_Obj;

/*
 *  ======== Processor_ATTRS ========
 */
static String argv[] = {"", NULL};

Processor_Attrs Processor_ATTRS = {
    "dsp0",
    1,
    argv
};

#if MESSAGEQ_ENABLED

static Bool procCreate(Processor_Handle proc, String coreName);
static Void procDelete(Processor_Handle proc);

static Int16 perCoreHeapId(UInt32 coreId);
static Int32 perCoreNumMsgs(UInt32 coreId);
static Int32 perCoreMsgSize(UInt32 coreId);
static Int16 perCoreSharedRegionId(UInt32 coreId);
static Bool perCoreUserCreatedHeapFlag(UInt32 coreId);

static HeapBufMP_Handle defaultHeapH = NULL;
static Int defaultHeapRefCount = 0;
#endif

Registry_Desc ti_sdo_ce_ipc_processor_desc;

static Int regInit = 0;     /* Registry_addModule() called */

/*
 *  ======== Processor_create ========
 */
Processor_Handle Processor_create(String imageName, String linkCfg,
    Processor_Attrs *attrs)
{
    Processor_Handle proc = NULL;

    Log_print3(Diags_ENTRY, "[+E] Processor_create> "
            "Enter(imageName='%s', linkCfg='%s', attrs=0x%x)",
            (IArg)imageName, (IArg)linkCfg, (IArg)attrs);

#if MESSAGEQ_ENABLED
    /* This implementation requires attrs->name to be provided */
    if ((attrs == NULL) || (attrs->cpuId == NULL)) {
        Log_print0(Diags_USER7, "[+7] Processor_create> ERROR: invalid attrs");
        return (NULL);
    }

    if ((proc = xdc_runtime_Memory_alloc(NULL, sizeof(Processor_Obj),
            0, NULL)) == NULL) {
        Log_print0(Diags_USER7, "[+7] Processor_create> "
                "ERROR: Memory_alloc failed");
        return (NULL);
    }

    proc->hHeap = NULL;
    proc->heapId = (UInt16)Processor_INVALID;

    if (!procCreate(proc, attrs->cpuId)) {
        Processor_delete(proc);
        return (NULL);
    }
#endif

    Log_print1(Diags_EXIT, "[+X] Processor_create> return (0x%x)", (IArg)proc);

    return (proc);
}


/*
 *  ======== Processor_delete ========
 */
Void Processor_delete(Processor_Handle proc)
{
    Log_print1(Diags_ENTRY, "[+E] Processor_delete> Enter(proc=0x%x)",
            (IArg)proc);

#if MESSAGEQ_ENABLED
    if (proc != NULL) {
        procDelete(proc);

        Log_print1(Diags_USER1,
                "[+1] Processor_delete(0x%x) freeing object ...", (IArg)proc);
        xdc_runtime_Memory_free(NULL, proc, sizeof(Processor_Obj));
    }
#endif
    Log_print0(Diags_EXIT, "[+X] Processor_delete> return");
}


/*
 *  ======== Processor_init ========
 */
Void Processor_init(Void)
{
    Registry_Result   result;

    /*
     *  No need to reference count for Registry_addModule(), since there
     *  is no way to remove the module.
     */
    if (regInit == 0) {
        /* Register this module for logging */
        result = Registry_addModule(&ti_sdo_ce_ipc_processor_desc,
                Processor_MODNAME);
        Assert_isTrue(result == Registry_SUCCESS, (Assert_Id)NULL);

        if (result == Registry_SUCCESS) {
            /* Set the diags mask to the CE default */
            CESettings_init();
            CESettings_setDiags(Processor_MODNAME);
        }
        regInit = 1;
    }
}

/*
 *  ======== Processor_wait ========
 */
Int Processor_wait(Processor_Handle proc)
{
    return (-1);
}

/*
 *  ======== Processor_getCoreName ========
 */
String Processor_getCoreName(UInt32 id)
{
#if MESSAGEQ_ENABLED
    UInt16 mpId = (UInt16)id;

    return (MultiProc_getName(mpId));
#else
    return (NULL);
#endif
}

/*
 *  ======== Processor_getCoreId ========
 */
UInt32 Processor_getCoreId(String name)
{
#if MESSAGEQ_ENABLED
    UInt16 coreId = MultiProc_getId(name);

    if (coreId == MultiProc_INVALIDID) {
        return (Processor_INVALIDID);
    }
    else {
        return (coreId);
    }
#else
    return (0);
#endif
}

/*
 *  ======== Processor_getNumProcs ========
 */
UInt32 Processor_getNumProcs(Void)
{
#if MESSAGEQ_ENABLED
    return(MultiProc_getNumProcessors());
#else
    return (1);
#endif
}

/*
 *  ======== Processor_myCoreId ========
 */
UInt32 Processor_myCoreId(Void)
{
#if MESSAGEQ_ENABLED
    return(MultiProc_self());
#else
    return (0);
#endif
}

/*
 *  ======== Processor_getHeapId ========
 */
UInt16 Processor_getHeapId(UInt32 coreId)
{
    Int16 heapId = 0;

#if MESSAGEQ_ENABLED
    heapId = perCoreHeapId(coreId);
    if (heapId == Processor_INVALID) {
        heapId = Processor_defaultHeapId;
    }
#endif
    return(heapId);
}

/*
 *  ======== Processor_getMsgSize ========
 */
UInt32 Processor_getMsgSize(UInt32 coreId)
{
    Int32 msgSize = 0;

#if MESSAGEQ_ENABLED
    msgSize = perCoreMsgSize(coreId);
    if (msgSize == Processor_INVALID) {
        msgSize = Processor_defaultMsgSize;
    }
#endif
    return(msgSize);
}

/*
 *  ======== Processor_getNumMsgs ========
 */
UInt32 Processor_getNumMsgs(UInt32 coreId)
{
    Int32 numMsgs = 0;

#if MESSAGEQ_ENABLED
    numMsgs = perCoreNumMsgs(coreId);
    if (numMsgs == Processor_INVALID) {
        numMsgs = Processor_defaultNumMsgs;
    }
#endif
    return(numMsgs);
}

/*
 *  ======== Processor_getSharedRegionId ========
 */
UInt16 Processor_getSharedRegionId(UInt32 coreId)
{
    Int16 sharedRegionId = 0;

#if MESSAGEQ_ENABLED
    sharedRegionId = perCoreSharedRegionId(coreId);
    if (sharedRegionId == Processor_INVALID) {
        sharedRegionId = Processor_defaultSharedRegionId;
    }
#endif
    return(sharedRegionId);
}

/*
 *  ======== Processor_getUserCreatedHeapFlag ========
 */
Bool Processor_getUserCreatedHeapFlag(UInt32 coreId)
{
#if MESSAGEQ_ENABLED
    return(perCoreUserCreatedHeapFlag(coreId));
#else
    return (FALSE);
#endif
}

#if MESSAGEQ_ENABLED
static Int16 perCoreHeapId(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].heapId);
}

static Int32 perCoreMsgSize(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].msgSize);
}

static Int32 perCoreNumMsgs(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].numMsgs);
}

static Int16 perCoreSharedRegionId(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].sharedRegionId);
}

static Bool perCoreUserCreatedHeapFlag(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(FALSE);
    }

    return(Processor_commDescs[coreId].userCreatedHeap);
}
/*
 *  ======== procCreate ========
 */
static Bool procCreate(Processor_Handle proc, String coreName)
{
    Bool            retVal;
    HeapBufMP_Params heapP;
    Char heapName[32];     /* big enough? */
    UInt16          coreId;
    Int16           heapId = 0;
    UInt16          regionId;
    UInt32          numMsgs;
    UInt32          msgSize;
    Bool            createAndRegisterHeap;

    Log_print1(Diags_ENTRY, "[+E] Processor_create_d> Enter(proc=0x%x)",
            (IArg)proc);

    /* used later */
    coreId = Processor_getCoreId(coreName);

    if (coreId == Processor_INVALIDID) {
        Log_print1(Diags_USER7, "[+7] Processor_create_d> Invalid core: %s",
                (IArg)coreName);
        goto fail;
    }

    heapId = perCoreHeapId(coreId);
    createAndRegisterHeap = FALSE;

    if (heapId == Processor_INVALID) {
        /* runtime validation of user configuration */
        if (perCoreUserCreatedHeapFlag(coreId) == TRUE ||
            perCoreNumMsgs(coreId) != Processor_INVALID ||
            perCoreMsgSize(coreId) != Processor_INVALID ||
            perCoreSharedRegionId(coreId) != Processor_INVALID) {

            Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                       "Invalid heap configuration for core %d: "
                       "attempting to set other Processor_CommDesc "
                       "elements while Processor_CommDesc.heapId is "
                       "undefined",
                       coreId);

            goto fail;
        }

        /* will return default heapId since user didn't specify */
        heapId = Processor_getHeapId(coreId);

        if (defaultHeapRefCount++ == 0) {
            createAndRegisterHeap = TRUE;

            /* tell code below to record hHeap in defaultHeapH */
            defaultHeapH = (HeapBufMP_Handle)-1;
        }
    }
    else {
        if (perCoreUserCreatedHeapFlag(coreId) == FALSE) {
            createAndRegisterHeap = TRUE;
        }
    }

    if (createAndRegisterHeap) {
        /* create a heap for message queue usage */

        /* get either user-config'ed or module default */
        numMsgs = Processor_getNumMsgs(coreId);
        msgSize = Processor_getMsgSize(coreId);
        regionId = Processor_getSharedRegionId(coreId);

        /* create a heap for message queue usage */
        HeapBufMP_Params_init(&heapP);
        heapP.numBlocks = numMsgs;
        heapP.blockSize = msgSize;
        heapP.sharedAddr = NULL;
        heapP.regionId = regionId;
        if (defaultHeapH == (HeapBufMP_Handle)-1) {
            sprintf(heapName, "CE-default");
        }
        else {
            sprintf(heapName, "CE<->Svr%d", coreId);
        }
        heapP.name = heapName;

        Log_print2(Diags_USER1, "[+2] Processor_create_d> "
                "calling HeapBufMP_create(): nblocks %d, blocksize %d",
                heapP.numBlocks, heapP.blockSize);

        proc->hHeap = HeapBufMP_create(&heapP);

        if (proc->hHeap == NULL) {
            Log_print0(Diags_USER7, "[+7] Processor_create_d> "
                    "HeapBufMP_create failed");
            goto fail;
        }

        if (defaultHeapH == (HeapBufMP_Handle)-1) {
            /* we've just created the module default heap singleton */
            defaultHeapH = proc->hHeap;
        }

        /* register this heap with MessageQ */
        Log_print2(Diags_USER1, "[+2] Processor_create_d> "
            "MessageQ_registerHeap(hHeap: 0x%x, heapId: %d)",
            (IArg)(proc->hHeap), (IArg)heapId);

        if (MessageQ_registerHeap((Ptr)(proc->hHeap), heapId) !=
                MessageQ_S_SUCCESS) {
            Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                       "MessageQ_registerHeap() failed for heapId %d",
                       heapId);

            goto fail;
        }
    }

    proc->heapId = heapId;

    retVal = TRUE;
    goto procCreate_return;

fail:
    Log_print0(Diags_USER7, "[+7] Processor_create_d> "
            "Initializing DSP server FAILED");

    procDelete(proc);

    retVal = FALSE;

procCreate_return:

    Log_print1(Diags_USER2, "[+2] Processor_create_d> return (%d)",
            (IArg)retVal);

    return (retVal);
}

/*
 *  ======== procDelete ========
 */
static Void procDelete(Processor_Handle proc)
{
    Int16 heapId;
    Bool unregisterAndDeleteHeap;

    Log_print1(Diags_ENTRY, "[+E] Processor_delete_d> Enter (proc=0x%x)",
            (IArg)proc);

    if (proc == NULL) {
        goto procDelete_return;
    }

    if (proc->hHeap != NULL) {
        unregisterAndDeleteHeap = FALSE;
        if (proc->hHeap == defaultHeapH) {
            if (--defaultHeapRefCount == 0) {
                /* this is the last one using the default heap */
                unregisterAndDeleteHeap = TRUE;
            }
        }
        else {
            unregisterAndDeleteHeap = TRUE;
        }

        if (unregisterAndDeleteHeap) {
            heapId = proc->heapId;
            if (heapId != Processor_INVALID) {
                Log_print1(Diags_USER1, "[+1] Processor_delete_d> "
                           "MessageQ_unregisterHeap(heapId: %d)",
                           (IArg)heapId);

                if (MessageQ_unregisterHeap(heapId) != MessageQ_S_SUCCESS) {
                    Log_print1(Diags_USER7, "[+7] Processor_delete_d> "
                               "MessageQ_unregisterHeap(heapId: %d) "
                               "failed",
                               heapId);

                }
            }

            /* delete heap used by message queue */
            Log_print1(Diags_USER1, "[+1] Processor_delete_d> "
                       "calling HeapBufMP_delete(hHeap: 0x%x)",
                       (IArg)(proc->hHeap));

            HeapBufMP_delete(&proc->hHeap);
        }
    }

procDelete_return:

    Log_print1(Diags_EXIT, "[+X] Processor_delete_d> return", (IArg)proc);
}
#endif  /* MESSAGEQ_ENABLED */
/*
 *  @(#) ti.sdo.ce.ipc.bios; 2, 0, 1,1; 2-24-2012 19:29:56; /db/atree/library/trees/ce/ce-t06/src/ xlibrary

 */

