/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/*
 *  ======== Processor_dsplink.c ========
 */

/* This define must precede inclusion of any xdc header files */
#define Registry_CURDESC ti_sdo_ce_ipc_processor_desc

#include <xdc/std.h>
//#include <xdc/cfg/global.h>
#include <xdc/runtime/Assert.h>
#include <xdc/runtime/Diags.h>
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Registry.h>

#include <ti/sdo/ce/osal/Memory.h>
#include <ti/sdo/ce/osal/Global.h>
#include <xdc/runtime/knl/Thread.h>
#include <xdc/runtime/Gate.h>
#include <xdc/runtime/knl/GateThread.h>
#include <xdc/runtime/knl/SemThread.h>

#include <ti/sdo/ce/global/CESettings.h>

#include <ti/sdo/linuxutils/cmem/include/cmem.h>

#include <ti/sdo/ce/ipc/Comm.h>
#include <ti/sdo/ce/ipc/Processor.h>

/*  ----------------------------------- DSP/BIOS Link                   */
#include <ti/sdo/ce/ipc/dsplink/_adapted_link_gpptypes.h>

// conflicts w/ XDC std.h types
//#include <ti/sdo/syslink/utils/hlos/Std.h>

#define STD_H
typedef void *Handle;
#include <ti/ipc/HeapBufMP.h>
#include <ti/ipc/Ipc.h>
#include <ti/ipc/MessageQ.h>
#include <ti/ipc/MultiProc.h>
#include <ti/ipc/SharedRegion.h>
#include <ti/syslink/ProcMgr.h>
#include <ti/syslink/IpcHost.h>    /* For SysLink-specific Ipc_control() */
#include <ti/syslink/SysLink.h>

#undef Processor_Handle

#include <stdio.h>  /* for printf() and getchar() */
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>

// ladclient package build is currently disabled, so we shouldn't include
// this file.
//#include <ti/dsplink/utils/ladclient/ladclient.h>

#define Processor_defaultSharedRegionId ti_sdo_ce_ipc_dsplink__Processor_defaultSharedRegionId
#define Processor_defaultHeapId ti_sdo_ce_ipc_dsplink__Processor_defaultHeapId
#define Processor_defaultNumMsgs ti_sdo_ce_ipc_dsplink__Processor_defaultNumMsgs
#define Processor_defaultMsgSize ti_sdo_ce_ipc_dsplink__Processor_defaultMsgSize
#define Processor_commDescs ti_sdo_ce_ipc_dsplink__Processor_commDescs
#define Processor_numCommDescs ti_sdo_ce_ipc_dsplink__Processor_numCommDescs
#define Processor_loadSlave ti_sdo_ce_ipc_dsplink__Processor_loadSlave

/* Generated by .xdt file */
extern Int16 Processor_defaultSharedRegionId;
extern Int16 Processor_defaultHeapId;
extern Int32 Processor_defaultNumMsgs;
extern Int32 Processor_defaultMsgSize;
extern Processor_CommDesc Processor_commDescs[];
extern UInt32 Processor_numCommDescs;
extern Bool Processor_loadSlave;


/*
 *  ======== Processor_Obj ========
 */
typedef struct Processor_Obj {
    Int               cpuId;
    UInt16            heapId;
    String            imageName;
    String            memMapName;
    Bool              loaded;
    Processor_Attrs   attrs;
    ProcMgr_Handle    procMgrH;
    HeapBufMP_Handle  heapH;
    UInt32            fileId;
    Int32             loadCallBackStatus;
    Int32             startCallBackStatus;
    Bool              useExtLoader;
} Processor_Obj;

/*
 *  ======== Processor_ATTRS ========
 */
Processor_Attrs Processor_ATTRS = {
    "dsp0",     /* cpu ID */
    0,          /* argc */
    NULL,       /* argv */
    FALSE,      /* useExtLoader */
};

#define NONE    0
#define CREATE  1
#define DELETE  2
#define EXIT    3

#define SUCCESS 1
#define FAILURE 2

/*
 *  ======== CmdObj ========
 */
typedef struct CmdObj {
    Thread_Handle     dproc;
    Processor_Handle  proc;
    Int               cmdId;
    Int               reply;

    SemThread_Handle  cmdPresent;
    SemThread_Handle  replyPresent;
    GateThread_Handle gate;
} CmdObj;


/*
 *  Memory map entry format in map text file.
 */
typedef struct MapStruct {
    UInt32 slaveVirt;
    UInt32 slavePhys;
    UInt32 masterPhys;
    UInt32 size;
    UInt32 mapMask;
    int isCached;
} MapStruct;

/* REMINDER: if you add an initialized static var, reinitialize it at cleanup */

static CmdObj dcmd = {NULL, NULL, NONE, NONE, NULL, NULL, NULL};

static Bool mapByFile(ProcMgr_Handle handle, String mapFile, UInt16 procId,
        int mapFlag);
static int initFromLine(char *line, MapStruct *mapStruct);
static int isMapLine(char *line, UInt16 procId);

static Void cleanup(Void);
static Int daemon(Void);
static Int doCmd(Int cmdId, Processor_Handle proc);
static Int getCmd(Processor_Handle *proc);
static Bool procCreate(Processor_Handle proc);
static Void procDelete(Processor_Handle proc);
static Void putReply(Int status);

static Int16 perCoreHeapId(UInt32 coreId);
static Int32 perCoreNumMsgs(UInt32 coreId);
static Int32 perCoreMsgSize(UInt32 coreId);
static Int16 perCoreSharedRegionId(UInt32 coreId);
static Bool perCoreUserCreatedHeapFlag(UInt32 coreId);

Registry_Desc ti_sdo_ce_ipc_processor_desc;

static Int regInit = 0;     /* Registry_addModule() called */
static Int curInit = 0;     /* module init counter */

static HeapBufMP_Handle defaultHeapH = NULL;
static Int defaultHeapRefCount = 0;

/*
 *  ======== Processor_create ========
 */
Processor_Handle Processor_create(String imageName, String memMap,
    Processor_Attrs *attrs)
{
    Processor_Handle proc = NULL;
    struct stat statBuf;

    Assert_isTrue(curInit == TRUE, (Assert_Id)NULL);

    Log_print3(Diags_ENTRY, "[+E] Processor_create> "
            "Enter(imageName='%s', memMap='%s', attrs=0x%x)",
            (IArg)imageName, (IArg)memMap, (IArg)attrs);

    if (attrs == NULL) {
        attrs = &Processor_ATTRS;
    }

    if (stat(imageName, &statBuf) != 0) {
        Log_print1(Diags_USER7, "[+7] Processor_create> "
                "ERROR: cannot access file %s", (IArg)imageName);
        return (NULL);
    }

    proc = Memory_alloc(sizeof(Processor_Obj), NULL);
    if (proc == NULL) {
        Log_print0(Diags_USER7, "[+7] Processor_create> "
                "ERROR: Memory_alloc failed");
        return (NULL);
    }

    proc->attrs = *attrs;
    proc->imageName = imageName;
    proc->memMapName = memMap;
    proc->loaded = FALSE;
    proc->fileId = 0xffffffff;
    proc->heapH = NULL;
    proc->procMgrH = NULL;
    proc->heapId = Processor_INVALID;
    proc->loadCallBackStatus = -1;
    proc->startCallBackStatus = -1;
    proc->useExtLoader = attrs->useExtLoader;

    if (doCmd(CREATE, proc) != SUCCESS) {
        Processor_delete(proc);
        return (NULL);
    }
    proc->loaded = TRUE;

    Log_print1(Diags_EXIT, "[+X] Processor_create> return (0x%x)", (IArg)proc);

    return (proc);
}


/*
 *  ======== Processor_delete ========
 */
Void Processor_delete(Processor_Handle proc)
{
    Assert_isTrue(curInit == TRUE, (Assert_Id)NULL);

    Log_print1(Diags_ENTRY, "[+E] Processor_delete> Enter(proc=0x%x)",
            (IArg)proc);

    if (proc != NULL) {
        if (proc->loaded == TRUE && dcmd.dproc != NULL) {
            doCmd(DELETE, proc);
        }

        Log_print1(Diags_USER1,
                "[+1] Processor_delete(0x%x) freeing object ...", (IArg)proc);
        Memory_free(proc, sizeof(Processor_Obj), NULL);
    }

    Log_print0(Diags_EXIT, "[+X] Processor_delete> return");
}


/*
 *  ======== Processor_init ========
 */
Void Processor_init(Void)
{
    GateThread_Params params;
    Registry_Result   result;

    /*
     *  No need to reference count for Registry_addModule(), since there
     *  is no way to remove the module.
     */
    if (regInit == 0) {
        /* Register this module for logging */
        result = Registry_addModule(&ti_sdo_ce_ipc_processor_desc,
                Processor_MODNAME);
        Assert_isTrue(result == Registry_SUCCESS, (Assert_Id)NULL);

        if (result == Registry_SUCCESS) {
            /* Set the diags mask to the CE default */
            CESettings_init();
            CESettings_setDiags(Processor_MODNAME);
        }
        regInit = 1;
    }

    if (curInit != TRUE) {
        curInit = TRUE;

        /* Semaphore with count 0, will be posted when a command is present */
        dcmd.cmdPresent = SemThread_create(0, NULL, NULL);

        /* Semaphore with count 0, will be posted when reply is ready */
        dcmd.replyPresent = SemThread_create(0, NULL, NULL);

        /*
         *  Create lock to allow only one thread at a time to send command
         *  to the daemon.
         */
        GateThread_Params_init(&params);
        dcmd.gate = GateThread_create(&params, NULL);

        if ((dcmd.cmdPresent == NULL) || (dcmd.replyPresent == NULL) ||
                (dcmd.gate == NULL)) {
            // TODO: Shouldn't we abort?
            Log_print0(Diags_USER7, "[+7] Processor_init> ERROR: cannot"
                    " create semaphores or lock");
        }

        Log_print0(Diags_USER2, "[+2] Processor_init> SysLink_setup()...");

        SysLink_setup();
        Log_print0(Diags_USER2, "[+2] Processor_init> "
                "... SysLink_setup() done");

        if ((dcmd.dproc = Thread_create((Thread_RunFxn)daemon, NULL, NULL))
                == NULL) {
            Log_print0(Diags_USER7, "[+7] Processor_init> "
                    "ERROR: cannot create DSP daemon");
        }

        if (Thread_start(NULL) != TRUE) {
            Log_print0(Diags_USER7, "[+7] Processor_init> "
                    "ERROR: cannot start threads");
        }

        Global_atexit((Fxn)cleanup);
    }
}

/*
 *  ======== Processor_getCoreName ========
 */
String Processor_getCoreName(UInt32 id)
{
    UInt16 mpId = (UInt16)id;

    return(MultiProc_getName(mpId));
}


/*
 *  ======== Processor_getCoreId ========
 */
UInt32 Processor_getCoreId(String name)
{
    UInt16 coreId = MultiProc_getId(name);

    if (coreId == MultiProc_INVALIDID) {
        return (Processor_INVALIDID);
    }
    else {
        return ((UInt32)coreId);
    }
}

/*
 *  ======== Processor_getNumProcs ========
 */
UInt32 Processor_getNumProcs(Void)
{
    return(MultiProc_getNumProcessors());
}

/*
 *  ======== Processor_myCoreId ========
 */
UInt32 Processor_myCoreId(Void)
{
    return(MultiProc_self());
}

/*
 *  ======== Processor_getHeapId ========
 */
UInt16 Processor_getHeapId(UInt32 coreId)
{
    Int16 heapId;

    heapId = perCoreHeapId(coreId);
    if (heapId == Processor_INVALID) {
        heapId = Processor_defaultHeapId;
    }

    return(heapId);
}

/*
 *  ======== Processor_getMsgSize ========
 */
UInt32 Processor_getMsgSize(UInt32 coreId)
{
    Int32 msgSize;

    msgSize = perCoreMsgSize(coreId);
    if (msgSize == Processor_INVALID) {
        msgSize = Processor_defaultMsgSize;
    }

    return(msgSize);
}

/*
 *  ======== Processor_getNumMsgs ========
 */
UInt32 Processor_getNumMsgs(UInt32 coreId)
{
    Int32 numMsgs;

    numMsgs = perCoreNumMsgs(coreId);
    if (numMsgs == Processor_INVALID) {
        numMsgs = Processor_defaultNumMsgs;
    }

    return(numMsgs);
}

/*
 *  ======== Processor_getSharedRegionId ========
 */
UInt16 Processor_getSharedRegionId(UInt32 coreId)
{
    Int16 sharedRegionId;

    sharedRegionId = perCoreSharedRegionId(coreId);
    if (sharedRegionId == Processor_INVALID) {
        sharedRegionId = Processor_defaultSharedRegionId;
    }

    return(sharedRegionId);
}

/*
 *  ======== Processor_getUserCreatedHeapFlag ========
 */
Bool Processor_getUserCreatedHeapFlag(UInt32 coreId)
{
    return(perCoreUserCreatedHeapFlag(coreId));
}

static Int16 perCoreHeapId(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].heapId);
}

static Int32 perCoreMsgSize(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].msgSize);
}

static Int32 perCoreNumMsgs(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].numMsgs);
}

static Int16 perCoreSharedRegionId(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(Processor_INVALID);
    }

    return(Processor_commDescs[coreId].sharedRegionId);
}

static Bool perCoreUserCreatedHeapFlag(UInt32 coreId)
{
    if (coreId == MultiProc_INVALIDID ||
        coreId >= Processor_numCommDescs) {

        return(FALSE);
    }

    return(Processor_commDescs[coreId].userCreatedHeap);
}



/*
 *  ======== Processor_wait ========
 */
Int Processor_wait(Processor_Handle proc)
{
    return(-1);
}

/*
 *  ======== cleanup ========
 */
static Void cleanup(Void)
{
    static CmdObj dcmdInit = {NULL, NULL, NONE, NONE, NULL, NULL, NULL};

    if (curInit != FALSE) {
        curInit = FALSE;
        if (dcmd.dproc != NULL) {
            doCmd(EXIT, NULL);
            // Thread_join(dcmd.dproc);
            Thread_delete(&dcmd.dproc); /* will do join first? */
            dcmd.dproc = NULL;
        }

        Log_print0(Diags_USER2, "[+2] Processor cleanup()> "
                "SysLink_destroy()...");
        SysLink_destroy();
        Log_print0(Diags_USER2, "[+2] Processor cleanup()> "
                "... SysLink_destroy() complete");

        if (dcmd.cmdPresent != NULL) {
            SemThread_delete(&dcmd.cmdPresent);
            dcmd.cmdPresent = NULL;
        }

        if (dcmd.replyPresent != NULL) {
            SemThread_delete(&dcmd.replyPresent);
            dcmd.replyPresent = NULL;
        }

        if (dcmd.gate != NULL) {
            GateThread_delete(&dcmd.gate);
            dcmd.gate = NULL;
        }

        dcmd = dcmdInit;
    }
}

/*
 *  ======== procCreate ========
 */
static Bool procCreate(Processor_Handle proc)
{
    Int status = 0;
    Bool retVal;
    ProcMgr_AttachParams attachParams;
    ProcMgr_StartParams  startParams;
    ProcMgr_State        state;
    ProcMgr_AddrInfo     CMEMAddrInfo;
    HeapBufMP_Params heapP;
    CMEM_BlockAttrs cmemBlockAttrs;
    Int blockNum;
    Int nCMEMBlocks;
    Bool createAndRegisterHeap;
    Int16 heapId;
    UInt16 regionId;
    UInt32 numMsgs;
    UInt32 msgSize;
    Char heapName[32];

    Log_print1(Diags_ENTRY, "[+E] Processor_create_d> Enter(proc=0x%x)",
            (IArg)proc);

    /* Create and initialize the PROC object */
    Log_print1(Diags_USER2, "[+2] Processor_create_d> "
    "Retrieving CPU ID for '%s'...", (IArg)(proc->attrs.cpuId));

    proc->cpuId = Processor_getCoreId(proc->attrs.cpuId);
    if (proc->cpuId < 0) {
        Log_print1(Diags_USER7, "[+7] Processor_create_d> "
               "Processor_getCoreId() failed: %d", proc->cpuId);
        goto fail;
    }

    /* Open DSP ProcMgr */
    Log_print2(Diags_USER2, "[+2] Processor_create_d> "
           "Opening %s ProcMgr for cpuId %d...",
           (IArg)proc->attrs.cpuId, proc->cpuId);
    status = ProcMgr_open(&proc->procMgrH, proc->cpuId);

    if (status < 0) {
        Log_print1(Diags_USER7, "[+7] Processor_create_d> "
               "ProcMgr_open() failed: %d", (IArg)status);
        goto fail;
    }

    /* Attach the DSP */
    Log_print1(Diags_USER2, "[+2] Processor_create_d> "
           "Attaching to %s...", (IArg)proc->attrs.cpuId);

    if (proc->useExtLoader == FALSE) {
        /* We load the slave */
        ProcMgr_getAttachParams(NULL, &attachParams);
        status = ProcMgr_attach(proc->procMgrH, &attachParams);
        if (status < 0) {
            Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                    "ProcMgr_attach() failed: %d", (IArg)status);
            goto fail;
        }

        /* Map slave memory */
        if (!mapByFile(proc->procMgrH, proc->memMapName, proc->cpuId, TRUE)) {
            Log_print0(Diags_USER6, "Processor_create_d> mapByFile() failed!");
        }

        /* Load the executable on the DSP */
        Log_print3(Diags_USER2, "[+2] Processor_create_d> "
                "Loading %s on %s (%d args)...",
                (IArg)(proc->imageName), (IArg)(proc->attrs.cpuId),
                (IArg)(proc->attrs.argc));

        status = ProcMgr_load(proc->procMgrH, proc->imageName,
                proc->attrs.argc, proc->attrs.argv, NULL, &proc->fileId);
        if (status < 0) {
            Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                    "ProcMgr_load() failed: %d", status);
            goto fail;
        }

        /* temporary: to be done by SysLink in the future */
        Log_print0(Diags_USER1, "[+2] Processor_create_d> "
                "calling Ipc_control(LOADCALLBACK)...");
        status = Ipc_control(proc->cpuId, Ipc_CONTROLCMD_LOADCALLBACK, NULL);
        Log_print1(Diags_USER1, "[+2] Processor_create_d> "
                "Ipc_control(LOADCALLBACK) status: %d", (IArg)status);

        /* Start execution on DSP */
        Log_print1(Diags_USER2, "[+2] Processor_create_d> Starting %s ...",
                (IArg)proc->attrs.cpuId);

        ProcMgr_getStartParams(proc->procMgrH, &startParams);
        status = ProcMgr_start(proc->procMgrH, &startParams);
        if (status < 0) {
            Log_print1(Diags_USER7, "Processor_create_d> "
                    "ProcMgr_start() failed: %d", status);
            goto fail;
        }
    } // if (proc->useExtLoader == FALSE)
    else {
        /* Check the state of the processor to make sure it's really running */
        state = ProcMgr_getState(proc->procMgrH);
        if (state != ProcMgr_State_Running) {
            Log_print1(Diags_USER7, "Processor_create_d> Invalid processor "
                    "state [%d].", state);
            goto fail;
        }

        Log_print0(Diags_USER1, "[+2] Processor_create_d> "
                "calling Ipc_control(LOADCALLBACK)...");
        status = Ipc_control(proc->cpuId, Ipc_CONTROLCMD_LOADCALLBACK, NULL);
        proc->loadCallBackStatus = status;
        Log_print1(Diags_USER1, "[+2] Processor_create_d> "
                "Ipc_control(LOADCALLBACK) status: %d", (IArg)status);

        if (status < 0) {
            Log_print1(Diags_USER7, "Processor_create_d> "
                    "Ipc_control(LOADCALLBACK) failed: %d", status);
            goto fail;
        }
    }

    status = Ipc_control(proc->cpuId, Ipc_CONTROLCMD_STARTCALLBACK, NULL);
    proc->startCallBackStatus = status;
    Log_print1(Diags_USER1, "[+2] Processor_create_d> "
            "Ipc_control(STARTCALLBACK) status: %d", (IArg)status);
    if (status < 0) {
        Log_print1(Diags_USER7, "Processor_create_d> "
                "Ipc_control(STARTCALLBACK) failed: %d", status);
        goto fail;
    }


    /* get user-specified heapId */
    heapId = perCoreHeapId(proc->cpuId);
    createAndRegisterHeap = FALSE;

    if (heapId == Processor_INVALID) {
        /* runtime validation of user configuration */
        if (perCoreUserCreatedHeapFlag(proc->cpuId) == TRUE ||
                perCoreNumMsgs(proc->cpuId) != Processor_INVALID ||
                perCoreMsgSize(proc->cpuId) != Processor_INVALID ||
                perCoreSharedRegionId(proc->cpuId) != Processor_INVALID) {

            Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                    "Invalid heap configuration for core %d: "
                    "attempting to set other Processor_CommDesc "
                    "elements while Processor_CommDesc.heapId is "
                    "undefined",
                    proc->cpuId);

            goto fail;
        }

        /* will return default heapId since user didn't specify */
        heapId = Processor_getHeapId(proc->cpuId);

        if (defaultHeapRefCount++ == 0) {
            createAndRegisterHeap = TRUE;

            /* tell code below to record heapH in defaultHeapH */
            defaultHeapH = (HeapBufMP_Handle)-1;
        }
    }
    else {
        if (perCoreUserCreatedHeapFlag(proc->cpuId) == FALSE) {
            createAndRegisterHeap = TRUE;
        }
    }

    if (createAndRegisterHeap) {
        /* create a heap for message queue usage */

        /* get either user-config'ed or module default */
        numMsgs = Processor_getNumMsgs(proc->cpuId);
        msgSize = Processor_getMsgSize(proc->cpuId);
        regionId = Processor_getSharedRegionId(proc->cpuId);

        HeapBufMP_Params_init(&heapP);
        heapP.numBlocks = numMsgs;
        heapP.blockSize = msgSize;
        heapP.sharedAddr = NULL;
        heapP.regionId = regionId;
        if (defaultHeapH == (HeapBufMP_Handle)-1) {
            sprintf(heapName, "CE-default");
        }
        else {
            sprintf(heapName, "CE<->Svr%d", proc->cpuId);
        }
        heapP.name = heapName;

        Log_print2(Diags_USER1, "[+2] Processor_create_d> "
                "calling HeapBufMP_create(): nblocks %d, blocksize 0x%x",
                heapP.numBlocks, heapP.blockSize);

        proc->heapH = HeapBufMP_create(&heapP);

        if (proc->heapH == NULL) {
            Log_print0(Diags_USER7, "[+7] Processor_create_d> "
                    "HeapBufMP_create failed");
            goto fail;
        }

        if (defaultHeapH == (HeapBufMP_Handle)-1) {
            /* we've just created the module default heap singleton */
            defaultHeapH = proc->heapH;
        }

        /* register this heap with MessageQ */
        Log_print2(Diags_USER1, "[+2] Processor_create_d> "
                "MessageQ_registerHeap(heapH: 0x%x, heapId: %d)",
                (IArg)(proc->heapH), (IArg)heapId);

        if (MessageQ_registerHeap((Ptr)(proc->heapH), heapId) !=
                    MessageQ_S_SUCCESS) {
        Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                "MessageQ_registerHeap() failed for heapId %d", heapId);

        goto fail;
        }
    }
    else {
        /*
         *  createAndRegisterHeap == FASLE
         *  If using the default heap, need to set proc->heapH for use by
         *  procDelete().
         */
        if (heapId == Processor_defaultHeapId) {
            proc->heapH = defaultHeapH;
        }
    }

    proc->heapId = heapId;

    blockNum = 0;
    nCMEMBlocks = 0;
    status = CMEM_getNumBlocks(&nCMEMBlocks);
    if (status != 0) {
        Log_print1(Diags_USER2, "[+2] Processor_create_d> "
                "CMEM_getNumBlocks() failed, not registering: %d",
                status);
    }

    while (blockNum < nCMEMBlocks) {
        status = CMEM_getBlockAttrs(blockNum, &cmemBlockAttrs);
        if (status != 0) {
            Log_print2(Diags_USER7, "[+7] Processor_create_d> "
                    "CMEM_getBlockAttrs(%d) failed: %d",
                    blockNum, status);

            goto fail;
        }

        CMEMAddrInfo.addr[ProcMgr_AddrType_MasterPhys] =
                cmemBlockAttrs.phys_base;
        CMEMAddrInfo.addr[ProcMgr_AddrType_SlaveVirt] =
                cmemBlockAttrs.phys_base;
        CMEMAddrInfo.size = cmemBlockAttrs.size;
        CMEMAddrInfo.isCached = FALSE;

        Log_print3(Diags_USER1, "[+1] Processor_create_d> CMEM block "
                "#%d found, doing ProcMgr_map(0x%x, 0x%x)...", blockNum,
                (IArg)cmemBlockAttrs.phys_base,
                (IArg)cmemBlockAttrs.size);

        status = ProcMgr_map(proc->procMgrH, ProcMgr_SLAVEVIRT, &CMEMAddrInfo,
                ProcMgr_AddrType_MasterPhys);
        if (status < 0) {
            Log_print1(Diags_USER7, "[+7] Processor_create_d> "
                    "ProcMgr_map() failed: %d", status);
            goto fail;
        }

        if (CMEMAddrInfo.addr[ProcMgr_AddrType_SlaveVirt] !=
                cmemBlockAttrs.phys_base) {
            Log_print2(Diags_USER1, "[+2] Processor_create_d> "
                    "mapped CMEM slave virtual address 0x%x doesn't "
                    "match expected value 0x%x",
                    CMEMAddrInfo.addr[ProcMgr_AddrType_SlaveVirt],
                    cmemBlockAttrs.phys_base);
        }

        blockNum++;
    }

    if (Global_getenv("CE_DSPDEBUG") != NULL) {
        printf("Codec Engine system message (b/c CE_DSPDEBUG=1) : %s image "
               "loaded and started, press Enter to continue: ",
               proc->attrs.cpuId);
        getchar();
    }

    retVal = TRUE;
    goto procCreate_return;

    /* TODO:[4] should try those asyncErrorHandlers that link supports?
     * (MSGQ_SetErrorHandler)
     */

fail:
    Log_print3(Diags_USER7, "[+7] Processor_create_d> "
            "Loading and starting %s server '%s' FAILED, status=[0x%x]",
            (IArg)proc->attrs.cpuId, (IArg)proc->imageName, status);

    procDelete(proc);

    retVal = FALSE;

procCreate_return:

    Log_print1(Diags_USER2, "[+2] Processor_create_d> return (%d)",
            (IArg)retVal);

    return (retVal);
}

/*
 *  ======== procDelete ========
 */
static Void procDelete(Processor_Handle proc)
{
    Int status = 0;
    Int16 heapId;
    Bool unregisterAndDeleteHeap;
    ProcMgr_AddrInfo CMEMAddrInfo;
    CMEM_BlockAttrs cmemBlockAttrs;
    Int blockNum;
    Int nCMEMBlocks;

    Log_print1(Diags_ENTRY, "[+E] Processor_delete_d> Enter (proc=0x%x)",
            (IArg)proc);

    if (proc == NULL) {
        goto procDelete_return;
    }

    /* close tranport and stop DSP, detach, destroy */
    /* unregister this heap with MessageQ */

    if (proc->startCallBackStatus >= 0) {
        blockNum = 0;
        nCMEMBlocks = 0;
        status = CMEM_getNumBlocks(&nCMEMBlocks);
        if (status != 0) {
            Log_print1(Diags_USER2, "[+2] Processor_delete_d> "
                    "CMEM_getNumBlocks() failed: %d",
                    status);
        }

        while (blockNum < nCMEMBlocks) {
            status = CMEM_getBlockAttrs(blockNum, &cmemBlockAttrs);
            if (status != 0) {
                Log_print2(Diags_USER7, "[+7] Processor_delete_d> "
                        "CMEM_getBlockAttrs(%d) failed: %d",
                        blockNum, status);

                goto cmemDone;
            }

            CMEMAddrInfo.addr[ProcMgr_AddrType_MasterPhys] =
                cmemBlockAttrs.phys_base;
            CMEMAddrInfo.addr[ProcMgr_AddrType_SlaveVirt] =
                cmemBlockAttrs.phys_base;
            CMEMAddrInfo.size = cmemBlockAttrs.size;
            CMEMAddrInfo.isCached = FALSE;

            Log_print3(Diags_USER1, "[+1] Processor_delete_d> CMEM block "
                    "#%d found, doing ProcMgr_unmap(0x%x, 0x%x)...", blockNum,
                    (IArg)cmemBlockAttrs.phys_base,
                    (IArg)cmemBlockAttrs.size);

            status = ProcMgr_unmap(proc->procMgrH, ProcMgr_SLAVEVIRT,
                    &CMEMAddrInfo,
                    ProcMgr_AddrType_MasterPhys);
            if (status < 0) {
                Log_print1(Diags_USER7, "[+7] Processor_delete_d> "
                        "ProcMgr_unmap() failed: %d", status);
                goto cmemDone;
            }

            blockNum++;
        }

cmemDone:
        Log_print2(Diags_USER7, "[+2] Processor_delete_d> "
                "defaultHeapH: 0x%x, proc->heapH: 0x%x", (IArg)defaultHeapH,
                (IArg)proc->heapH);
        if (proc->heapH != NULL) {
            unregisterAndDeleteHeap = FALSE;
            if (proc->heapH == defaultHeapH) {
                Log_print1(Diags_USER1, "[+1] Processor_delete_d> "
                        "defaultHeapRefCount = %d",
                        (IArg)defaultHeapRefCount);
                if (--defaultHeapRefCount == 0) {
                    /* this is the last one using the default heap */
                    unregisterAndDeleteHeap = TRUE;
                }
            }
            else {
                unregisterAndDeleteHeap = TRUE;
            }

            if (unregisterAndDeleteHeap) {
                heapId = proc->heapId;
                Log_print1(Diags_USER1, "[+1] Processor_delete_d> "
                        "unregisterAndDeleteHeap, heapId = %d", (IArg)heapId);
                if (heapId != Processor_INVALID) {
                    Log_print1(Diags_USER1, "[+1] Processor_delete_d> "
                            "MessageQ_unregisterHeap(heapId: %d)",
                            (IArg)heapId);

                    if (MessageQ_unregisterHeap(heapId) !=MessageQ_S_SUCCESS) {
                        Log_print1(Diags_USER7, "[+7] Processor_delete_d> "
                                "MessageQ_unregisterHeap(heapId: %d) failed",
                                heapId);
                    }
                }

                /* delete heap used by message queue */
                Log_print1(Diags_USER1, "[+1] Processor_delete_d> "
                        "calling HeapBufMP_delete(heapH: 0x%x)",
                        (IArg)(proc->heapH));

                HeapBufMP_delete(&proc->heapH);
            }
        }

        /* Stop execution on DSP */
        Log_print0(Diags_USER1, "[+2] Processor_delete_d> "
                "calling Ipc_control(STOPCALLBACK)...");
        status = Ipc_control(proc->cpuId, Ipc_CONTROLCMD_STOPCALLBACK, NULL);

        Log_print2(Diags_USER2, "[+2] Processor_delete_d> "
                "Ipc_control(STOPCALLBACK) status: 0x%x [%d]", (IArg)status,
                (IArg)status);
    }
    else {
        Log_print2(Diags_USER2, "[+2] Processor_delete_d> Not calling "
                "Ipc_control(STOPCALLBACK) because startCallBackStatus =  "
                "0x%x [%d]", (IArg)proc->startCallBackStatus,
                (IArg)proc->startCallBackStatus);
    }

    if (proc->useExtLoader == FALSE) {
        /* We unload the slave processor */
        Log_print0(Diags_USER2, "[+2] Processor_delete_d> Stopping DSP...");

        status = ProcMgr_stop(proc->procMgrH);
        if (status < 0) {
            Log_print1(Diags_USER6, "[+6] Processor_delete_d> "
                    "Stopping DSP FAILED, status=0x%x", (IArg)status);
        }

        if (proc->fileId != 0xffffffff) {
            Log_print0(Diags_USER2, "[+2] Processor_delete_d> "
                    "Unloading DSP...");
            status = ProcMgr_unload(proc->procMgrH, proc->fileId);
            if (status < 0) {
                Log_print1(Diags_USER6, "[+6] Processor_delete_d> "
                        "Unloading DSP FAILED, status=0x%x", (IArg)status);
            }
        }

        /* Unmap slave memory */
        if (!mapByFile(proc->procMgrH, proc->memMapName, proc->cpuId, FALSE)) {
            Log_print0(Diags_USER6, "Processor_delete_d> mapByFile() failed!");
        }

        /* Detach from the processor */
        Log_print0(Diags_USER1, "[+1] Processor_delete_d> "
                "calling ProcMgr_detach()...");

        status = ProcMgr_detach(proc->procMgrH);
        if (status < 0) {
            Log_print1(Diags_USER6, "[+6] Processor_delete_d> "
                    "Detaching from DSP FAILED, status=0x%x", (IArg)status);
        }
    } // proc->useExtLoader == FALSE

    Log_print0(Diags_USER1, "[+1] Processor_delete_d> "
            "calling ProcMgr_close()...");

    status = ProcMgr_close(&proc->procMgrH);
    if (status < 0) {
        Log_print1(Diags_USER6, "[+6] Processor_delete_d> "
                "Closing ProcMgr FAILED, status=0x%x", (IArg)status);
    }

procDelete_return:

    Log_print0(Diags_EXIT, "[+X] Processor_delete_d> return");
}

/*
 *  ======== doCmd ========
 */
static Int doCmd(Int cmdId, Processor_Handle proc)
{
    Int result;
    IArg key;

    Log_print2(Diags_ENTRY, "[+E] doCmd> Enter (cmdId=%d, proc=0x%x)",
            (IArg)cmdId, (IArg)proc);

    //pthread_mutex_lock(&dcmd.gate);
    key = GateThread_enter(dcmd.gate);

    dcmd.proc = proc;
    dcmd.cmdId = cmdId;
    //pthread_cond_signal(&dcmd.cmdPresent);
    SemThread_post(dcmd.cmdPresent, NULL);

    //while (dcmd.reply == NONE) {
    //    pthread_cond_wait(&dcmd.replyPresent, &dcmd.gate);
    //}
    SemThread_pend(dcmd.replyPresent, SemThread_FOREVER, NULL);

    result = dcmd.reply;
    dcmd.reply = NONE;

    //pthread_mutex_unlock(&dcmd.gate);
    GateThread_leave(dcmd.gate, key);

    Log_print1(Diags_EXIT, "[+X] doCmd> Exit (result=%d)", (IArg)result);

    return (result);
}

/*
 *  ======== getCmd ========
 */
static Int getCmd(Processor_Handle *proc)
{
    Int result;

    Log_print1(Diags_ENTRY, "[+E] getCmd_d> Enter (proc=0x%x)", (IArg)proc);

    //pthread_mutex_lock(&dcmd.gate);

    //while (dcmd.cmdId == NONE) {
    //    pthread_cond_wait(&dcmd.cmdPresent, &dcmd.gate);
    //}
    SemThread_pend(dcmd.cmdPresent, SemThread_FOREVER, NULL);

    result = dcmd.cmdId;
    *proc = dcmd.proc;
    dcmd.cmdId = NONE;

    //pthread_mutex_unlock(&dcmd.gate);
    Log_print1(Diags_EXIT, "[+X] getCmd_d> Exit (result=%d)", (IArg)result);

    return (result);
}

/*
 *  ======== putReply ========
 */
static Void putReply(Int status)
{
    //pthread_mutex_lock(&dcmd.gate);

    dcmd.reply = status;

    //pthread_cond_signal(&dcmd.replyPresent);
    SemThread_post(dcmd.replyPresent, NULL);

    //Log_print2(Diags_USER1, "putReply(0x%x): proc = 0x%lx",
    //        (IArg)status, (IArg)(dcmd.proc));

    //pthread_mutex_unlock(&dcmd.gate);
}

/*
 *  ======== daemon ========
 */
static Int daemon(Void)
{

    Log_print0(Diags_USER1, "[+1] daemon> thread created.");

    for (;;) {
        Processor_Handle proc;

        switch (getCmd(&proc)) {
            case CREATE: {
                putReply(procCreate(proc) ? SUCCESS : FAILURE);
                break;
            }

            case DELETE: {
                /* Log_print1(Diags_USER1, "daemon(0x%x) deleting ...",
                 *   (IArg)proc);
                 */
                procDelete(proc);
                /* Log_print1(Diags_USER1, "daemon(0x%x) replying ...",
                 *   (IArg)proc);
                 */
                putReply(SUCCESS);

                break;
            }

            case EXIT: {
                //Log_print0(Diags_USER1, "daemon> thread terminating");
                putReply(SUCCESS);
                return (0);
            }

            default: {
                break;
            }
        }
    }
}

/*
 *  Code below is temporary, until ProcMgr has an API to map by file.
 */

#define MUV ProcMgr_AddrType_MasterUsrVirt
#define MKV ProcMgr_AddrType_MasterKnlVirt
#define MP ProcMgr_AddrType_MasterPhys
#define MAXLINE 100

/*
 *  ======== mapByFile ========
 */
Bool mapByFile(ProcMgr_Handle handle, String mapFile, UInt16 procId,
        int mapFlag)
{
    FILE *f;
    char line[MAXLINE];
    MapStruct mapStruct;
    ProcMgr_AddrInfo addrInfo;
    Int status = 0;
    ProcMgr_ProcInfo *procInfo;
    Int procInfoSize;
    UInt32 maxMemoryRegions;
    int j;

    if (mapFile == NULL) {
        return (TRUE);
    }

    f = fopen(mapFile, "r");

    if (!f) {
        Log_print1(Diags_USER5, "[+5] mapByFile: Unable to open %s "
                "skipping....", (IArg)mapFile);

        /* regardless, we return 'success'.  Malformed lines are skipped */
        return (TRUE);
    }

    while (fgets(line, MAXLINE, f)) {
        if (!isMapLine(line, procId)) {
            Log_print1(Diags_USER5, "malformed line, skipping:\n   %s",
                    (IArg)line);
            continue;
        }

        /* Parse line, if not applicable, continue */
        if (!initFromLine(line, &mapStruct)) {
            continue;
        }

        /* applicable line */
        if (mapFlag) {
            /* map! */
            Log_print6(Diags_USER2,
                    "[+2] mapByFile: Mapping SV: 0x%x, SP: 0x%x, "
                    "MP: 0x%x,\n  size 0x%x, mask 0x%x, cached %d",
                    (IArg)mapStruct.slaveVirt, (IArg)mapStruct.slavePhys,
                    (IArg)mapStruct.masterPhys, (IArg)mapStruct.size,
                    (IArg)mapStruct.mapMask, (IArg)mapStruct.isCached);

            addrInfo.addr[MKV] = -1u;
            addrInfo.addr[ProcMgr_AddrType_MasterUsrVirt] = -1u;
            addrInfo.addr[MP] = mapStruct.masterPhys;
            addrInfo.addr[ProcMgr_AddrType_SlaveVirt] = mapStruct.slaveVirt;
            addrInfo.addr[ProcMgr_AddrType_SlavePhys] = -1u;
            addrInfo.size = mapStruct.size;
            addrInfo.isCached = mapStruct.isCached;

            status = ProcMgr_map(handle, mapStruct.mapMask, &addrInfo, MP);
            if (status < 0) {
                Log_print1(Diags_USER6, "[+6] mapByFile: ProcMgr_map "
                        "failed [0x%x]", (IArg)status);
            }
            else {
                Log_print0(Diags_USER2, "[+2] mapByFile: mapping succeeded");
            }
        }
        else {
            /* unmap! */
            Log_print6(Diags_USER2, "[+2]Unmapping SV: 0x%x, SP: 0x%x, "
                    "MP: 0x%x,\n  size 0x%x, mask 0x%x, cached %d",
                    (IArg)mapStruct.slaveVirt, (IArg)mapStruct.slavePhys,
                    (IArg)mapStruct.masterPhys, (IArg)mapStruct.size,
                    (IArg)mapStruct.mapMask, (IArg)mapStruct.isCached);

            addrInfo.addr[MKV] = -1u;

            /* if unmapping MasterKnlVirt, need to look it up */
            if (mapStruct.mapMask & ProcMgr_MASTERKNLVIRT) {

                maxMemoryRegions = ProcMgr_getMaxMemoryRegions(handle);
                procInfoSize = sizeof(ProcMgr_ProcInfo) +
                           (maxMemoryRegions * sizeof(ProcMgr_MappedMemEntry));
                procInfo = Memory_alloc(procInfoSize, NULL);

                status = ProcMgr_getProcInfo(handle, procInfo);
                if (status < 0) {
                    Log_print0(Diags_USER6, "[+6] Unable to find MKV entry");
                }
                else {
                    for (j = 0; j < procInfo->maxMemoryRegions; j++) {
                        if ((procInfo->memEntries[j].inUse) &&
                                (procInfo->memEntries[j].info.addr[MP]
                                        == mapStruct.masterPhys) &&
                                (procInfo->memEntries[j].info.size ==
                                        mapStruct.size) &&
                                (procInfo->memEntries[j].info.isCached
                                        == mapStruct.isCached)) {
                            /* found it */
                            addrInfo.addr[MKV] =
                                procInfo->memEntries[j].info.addr[MKV];
                            Log_print1(Diags_USER2,
                                    "[+2] Found MKV entry (0x%x)",
                                    (IArg)addrInfo.addr[MKV]);
                            break;
                        }
                    }
                }

                Memory_free(procInfo, procInfoSize, NULL);
            }

            addrInfo.addr[ProcMgr_AddrType_MasterUsrVirt] = -1u;
            addrInfo.addr[MP] = mapStruct.masterPhys;
            addrInfo.addr[ProcMgr_AddrType_SlaveVirt] =
                mapStruct.slaveVirt;
            addrInfo.addr[ProcMgr_AddrType_SlavePhys] = -1u;
            addrInfo.size = mapStruct.size;
            addrInfo.isCached = mapStruct.isCached;

            status = ProcMgr_unmap(handle, mapStruct.mapMask, &addrInfo, MP);
            if (status < 0) {
                Log_print1(Diags_USER6, "[+6] ProcMgr_unmap failed [0x%x]",
                        status);
            }
            else {
                Log_print0(Diags_USER2, "[+2] ProcMgr_unmap succeeded");
            }
        }
    }

    fclose(f);

    /* regardless, we return 'success'.  Malformed lines are skipped */
    return (TRUE);
}

/*
 *  ======== initFromLine ========
 */
int initFromLine(char *line, MapStruct *mapStruct)
{
    int retval = FALSE;
    char *p;

    mapStruct->slaveVirt = 0;
    mapStruct->slavePhys = 0;
    mapStruct->masterPhys = 0;
    mapStruct->size = 0;
    mapStruct->mapMask = 0;
    mapStruct->isCached = FALSE;

    p = strtok(line, " ,");
    if (p) {
        /* procName */
        p = strtok(NULL, " ,");
        if (p) {
            /* slaveVirt, in hex */
            mapStruct->slaveVirt = strtoul(p, NULL, 16);
            if (mapStruct->slaveVirt == 0) {
                /* error, exit */
                Log_print0(Diags_USER6, "[+6] Error parsing slaveVirt");
                p = NULL;
            }
            else {
                p = strtok(NULL, " ,");
            }
        }
        if (p) {
            /* slavePhys, in hex */
            mapStruct->slavePhys = strtoul(p, NULL, 16);
            if (mapStruct->slavePhys == 0) {
                /* error, exit */
                Log_print0(Diags_USER6, "[+6] Error parsing slavePhys");
                p = NULL;
            }
            else {
                p = strtok(NULL, " ,");
            }
        }
        if (p) {
            /* masterPhys, in hex */
            mapStruct->masterPhys = strtoul(p, NULL, 16);
            if (mapStruct->masterPhys == 0) {
                /* error, exit */
                Log_print0(Diags_USER6, "[+6] Error parsing masterPhys");
                p = NULL;
            }
            else {
                p = strtok(NULL, " ,");
            }
        }
        if (p) {
            /* size, in hex */
            mapStruct->size = strtoul(p, NULL, 16);
            if (mapStruct->size == 0) {
                /* error, exit */
                Log_print0(Diags_USER6, "[+6] Error parsing size");
                p = NULL;
            }
            else {
                p = strtok(NULL, " ,");
            }
        }
        if (p) {
            /* Mask */
            mapStruct->mapMask = strtoul(p, NULL, 16);
            if (mapStruct->mapMask == 0) {
                /* error, exit */
                Log_print0(Diags_USER6, "[+6] Error parsing mask");
                p = NULL;
            }
            else {
                p = strtok(NULL, " ,");
            }
        }
        if (p) {
            /* cached */
            errno = 0;
            mapStruct->isCached = strtoul(p, NULL, 16);
            if ((errno != 0) ||
                    ((mapStruct->isCached != 0) && mapStruct->isCached != 1)) {
                /* error, exit */
                Log_print0(Diags_USER6, "[+6] Error parsing cached");
                p = NULL;
            }
            else {
                /* that's it! */
                retval = TRUE;
            }
        }
    }

    return (retval);
}

/*
 *  ======== isMapLine ========
 */
int isMapLine(char *line, UInt16 procId)
{
    int  retval = FALSE;
    char procName[32];

    if (line[0] != '#') {
        strncpy(procName, MultiProc_getName(procId), 32);
        if (strncmp(procName, line, strlen(procName)) == 0) {
            retval = TRUE;
        }
    }

    return (retval);
}
/*
 *  @(#) ti.sdo.ce.ipc.dsplink; 2, 0, 1,1; 2-24-2012 19:30:03; /db/atree/library/trees/ce/ce-t06/src/ xlibrary

 */

