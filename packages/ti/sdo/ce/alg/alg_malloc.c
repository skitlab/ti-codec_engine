/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/*
 *  ======== alg_malloc.c ========
 *  This module implements an algorithm memory management "policy" in which
 *  no memory is shared among algorithm objects.  Memory is, however
 *  reclaimed when objects are deleted.
 *
 *  preemption      sharing             object deletion
 *  ----------      -------             ---------------
 *  yes(*)          none                yes
 *
 *  Note 1: this module uses run-time support functions malloc() and free()
 *  to allocate and free memory.  Since these functions are *not* reentrant,
 *  either all object creation and deletion must be performed by a single
 *  thread or reentrant versions or these functions must be created.
 */

/* This define must precede inclusion of any xdc header files */
#define Registry_CURDESC ti_sdo_ce_alg_desc

#include <xdc/std.h>
#include <xdc/runtime/Assert.h>
#include <xdc/runtime/Diags.h>
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Registry.h>

#include <xdc/runtime/knl/SemProcess.h>

#include <ti/sdo/ce/osal/Memory.h>
#include <ti/sdo/ce/osal/Global.h>

#include <ti/sdo/ce/global/CESettings.h>

#include <ti/xdais/ialg.h>

#include <stdlib.h>     /* malloc/free declarations */
#include <string.h>     /* memset declaration */

#ifdef __GNUC__
#include <malloc.h> /* memalign declaration is here for Linux */
#endif

#include "alg.h"
#include "_alg.h"
#include "_Algorithm.h"


/*
 *  Base ID for semaphores in this module. This is auto-generated by
 *  Global.xdt.
 */
extern UInt32 ti_sdo_ce_alg_Algorithm_ipcKey;


Registry_Desc ti_sdo_ce_alg_desc;

static Int curInit = 0;     /* module init counter */
static Int regInit = 0;     /* Registry_addModule() called */

/*
 *  ======== ALG_releaseLock ========
 */
Void ALG_releaseLock(Int groupId, IALG_Handle alg)
{
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        Assert_isTrue(_ALG_sems[groupId] != NULL, (Assert_Id)NULL);
        SemProcess_post(_ALG_sems[groupId], NULL);
    }
}

/*
 *  ======== ALG_acquireLock ========
 */
Void ALG_acquireLock(Int groupId, IALG_Handle alg)
{
    /* acquire lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        Assert_isTrue(_ALG_sems[groupId] != NULL, (Assert_Id)NULL);
        SemProcess_pend(_ALG_sems[groupId], SemProcess_FOREVER, NULL);
    }
}

/*
 *  ======== ALG_activate ========
 */
Void ALG_activate(Int groupId, ALG_Handle alg)
{
    /* acquire lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        Assert_isTrue(_ALG_sems[groupId] != NULL, (Assert_Id)NULL);
        SemProcess_pend(_ALG_sems[groupId], SemProcess_FOREVER, NULL);
    }

    /* restore all persistant shared memory */
    /* nothing to do since memory allocation never shares any data */

    /* do app specific initialization of scratch memory */
    if (alg->fxns->algActivate != NULL) {
        alg->fxns->algActivate(alg);
    }
}

/*
 *  ======== ALG_addGroup ========
 */
Bool ALG_addGroup(Int groupId)
{
    Int     key;
    Bool    retVal = TRUE;

    Log_print1(Diags_ENTRY, "[+E] ALG_addGroup> Enter. groupId = %d",
            (IArg)groupId);

    if ((groupId < -1) || (groupId >= (Int)_ALG_NUMGROUPS)) {
        Log_print1(Diags_USER6, "[+6] ALG_addGroup> groupId: %d out of range.",
                (IArg)groupId);
        return (FALSE);
    }

    if (groupId >= 0) {
        if (_ALG_groupRefCount[groupId] == 0) {
            /* Create a semaphore for this groupId */
            key = (Int)ti_sdo_ce_alg_Algorithm_ipcKey + groupId;
            _ALG_sems[groupId] = SemProcess_create(1, key, NULL, NULL);

            if (_ALG_sems[groupId] == NULL) {
                Log_print1(Diags_USER6, "[+6] ALG_addGroup> Failed to create "
                        "semaphore for groupId %d.", (IArg)groupId);
                retVal = FALSE;
            }
        }

        if (retVal) {
            _ALG_groupRefCount[groupId]++;
        }
    }

    Log_print1(Diags_EXIT, "[+X] ALG_addGroup> Exit. status = %d",
            (IArg)retVal);

    return (retVal);
}


/*
 *  ======== ALG_deactivate ========
 */
Void ALG_deactivate(Int groupId, ALG_Handle alg)
{
    /* do app specific store of persistent data */
    if (alg->fxns->algDeactivate != NULL) {
        alg->fxns->algDeactivate(alg);
    }

    /* save all persistant shared memory */
    /* nothing to do since memory allocation never shares any data */

    /* release lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        Assert_isTrue(_ALG_sems[groupId] != NULL, (Assert_Id)NULL);
        SemProcess_post(_ALG_sems[groupId], NULL);
    }
}

/*
 *  ======== ALG_exit ========
 */
Void ALG_exit(Void)
{
    Int i;

    if (--curInit == 0) {
        /* De-initialize semaphores */
        for (i = 0; i < _ALG_NUMGROUPS; i++) {
            if (_ALG_sems[i]) {
                SemProcess_delete(&_ALG_sems[i]);
                _ALG_sems[i] = NULL;
                _ALG_groupRefCount[i] = 0;
            }
        }
    }
}

/*
 *  ======== ALG_init ========
 */
Void ALG_init(Void)
{
    Registry_Result   result;
    Int i;

    /*
     *  No need to reference count for Registry_addModule(), since there
     *  is no way to remove the module.
     */
    if (regInit == 0) {
        /* Register this module for logging */
        result = Registry_addModule(&ti_sdo_ce_alg_desc, ALG_MODNAME);
        Assert_isTrue(result == Registry_SUCCESS, (Assert_Id)NULL);

        if (result == Registry_SUCCESS) {
            /* Set the diags mask to the CE default */
            CESettings_init();
            CESettings_setDiags(ALG_MODNAME);
        }
        regInit = 1;
    }

    if (curInit++ == 0) {
        Log_print0(Diags_ENTRY, "[+E] ALG_init> Enter");

        /* Initialize semaphores with count 1 */
        for (i = 0; i < _ALG_NUMGROUPS; i++) {
            if (_ALG_groupUsed[i]) {
                _ALG_sems[i] = SemProcess_create(1,
                        (Int)ti_sdo_ce_alg_Algorithm_ipcKey + i,
                        NULL, NULL);
                _ALG_groupRefCount[i] = 1;
            }
            else {
                _ALG_sems[i] = NULL;
                _ALG_groupRefCount[i] = 0;
            }
            Log_print2(Diags_ENTRY, "[+E] _ALG_sems[%d] = 0x%x",
                    (IArg)i, (IArg)(_ALG_sems[i]));
        }

        /*
         *  Do not call Global_atexit() here. ALG_exit() will be called
         *  by Algorithm_exit(), which will have been registered with
         *  Global_atexit().
         */
    }
    else {
        Log_print0(Diags_USER2, "[+2] ALG_init> Enter");
    }

    Log_print0(Diags_EXIT, "[+X] ALG_init> Exit");
}


/*
 *  ======== _ALG_allocMemory ========
 */
Bool _ALG_allocMemory(IALG_MemRec memTab[], Int n)
{
    Log_print2(Diags_ENTRY, "_ALG_allocMemory> memTab=0x%x, n=%d",
            (IArg)memTab, (IArg)n);

    return (_ALG_allocMemory2(memTab, n, ALG_USECACHEDMEM_DEFAULT));
}

/*
 *  ======== _ALG_allocMemory2 ========
 */
Bool _ALG_allocMemory2(IALG_MemRec memTab[], Int n, UInt32 useCachedMem)
{
    Int i;
    Memory_AllocParams params;

    Log_print3(Diags_ENTRY, "_ALG_allocMemory2> memTab=0x%x, n=%d, "
            "useCachedMem=%d", (IArg)memTab, (IArg)n, (IArg)useCachedMem);

    params = Memory_DEFAULTPARAMS;

    params.type = ti_sdo_ce_alg_Algorithm_useHeap ? Memory_CONTIGHEAP :
                                                   Memory_CONTIGPOOL;

    switch (useCachedMem) {
        case ALG_USECACHEDMEM_DEFAULT:
            params.flags = ti_sdo_ce_alg_Algorithm_useCache ? Memory_CACHED :
                                                     Memory_NONCACHED;
            break;

        case ALG_USECACHEDMEM_CACHED:
            params.flags = Memory_CACHED;
            break;

        case ALG_USECACHEDMEM_NONCACHED:
            params.flags = Memory_NONCACHED;
            break;

        default:
            /* invalid useCachedMem, return failure */
            Log_print1(Diags_USER7, "_ALG_allocMemory2> Invalid "
                    "useCachedMem flag (0x%x)", useCachedMem);
            return (FALSE);
    }

    for (i = 0; i < n; i++) {
        params.align = memTab[i].alignment;
        memTab[i].base = Memory_alloc(memTab[i].size, &params);

        if (memTab[i].base == NULL) {
            _ALG_freeMemory2(memTab, i, useCachedMem);
            return (FALSE);
        }
        memset(memTab[i].base, 0, memTab[i].size);
    }


    Log_print0(Diags_EXIT, "_ALG_allocMemory2> Returning (TRUE)");
    return (TRUE);
}

/*
 *  ======== _ALG_freeMemory ========
 */
Void _ALG_freeMemory(IALG_MemRec memTab[], Int n)
{
    Log_print2(Diags_ENTRY, "_ALG_freeMemory> memTab=0x%x, n=%d",
            (IArg)memTab, (IArg)n);
    _ALG_freeMemory2(memTab, n, ALG_USECACHEDMEM_DEFAULT);
}

/*
 *  ======== _ALG_freeMemory2 ========
 */
Void _ALG_freeMemory2(IALG_MemRec memTab[], Int n, UInt32 useCachedMem)
{
    Int i;
    Memory_AllocParams params;

    Log_print3(Diags_ENTRY, "_ALG_freeMemory2> memTab=0x%x, n=%d, "
            "useCachedMem=%d", (IArg)memTab, (IArg)n, (IArg)useCachedMem);

    params = Memory_DEFAULTPARAMS;
    params.type = ti_sdo_ce_alg_Algorithm_useHeap ? Memory_CONTIGHEAP :
                                                    Memory_CONTIGPOOL;

    switch (useCachedMem) {
        case ALG_USECACHEDMEM_DEFAULT:
            params.flags = ti_sdo_ce_alg_Algorithm_useCache ? Memory_CACHED :
                                                              Memory_NONCACHED;
            break;

        case ALG_USECACHEDMEM_CACHED:
            params.flags = Memory_CACHED;
            break;

        case ALG_USECACHEDMEM_NONCACHED:
            params.flags = Memory_NONCACHED;
            break;

        default:
            /* invalid useCachedMem, return failure */
            Log_print1(Diags_USER7, "_ALG_allocMemory> Invalid "
                    "useCachedMem flag (0x%x)", useCachedMem);
            /* return here rather than continue and try to do something bad. */
            return;
    }

    for (i = 0; i < n; i++) {
        if (memTab[i].base != NULL) {
            Memory_free(memTab[i].base, memTab[i].size, &params);
        }
    }
}

/*
 *  ======== ALG_removeGroup ========
 */
Void ALG_removeGroup(Int groupId)
{
    Log_print1(Diags_ENTRY, "[+E] ALG_removeGroup> Enter. groupId = %d",
            (IArg)groupId);

    if ((groupId < -1) || (groupId >= (Int)_ALG_NUMGROUPS)) {
        Log_print1(Diags_USER6,
                "[+6] ALG_removeGroup> groupId: %d out of range.",
                (IArg)groupId);
        return;
    }

    if (groupId >= 0) {
        if (--_ALG_groupRefCount[groupId] == 0) {
            /* Delete semaphore for this groupId */
            SemProcess_delete(&_ALG_sems[groupId]);

            _ALG_sems[groupId] = NULL;
        }
    }

    Log_print0(Diags_EXIT, "[+X] ALG_removeGroup> Exit.");
}

/*
 *  @(#) ti.sdo.ce.alg; 1, 0, 1,1; 2-24-2012 19:27:09; /db/atree/library/trees/ce/ce-t06/src/ xlibrary

 */

